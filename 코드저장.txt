from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from app.db import models
from app.db.database import engine
from app.api.v1.api import api_router

# ì„œë²„ ì‹œì‘ ì‹œ models.pyì— ì •ì˜ëœ ëª¨ë“  í…Œì´ë¸”ì„ DBì— ìƒì„±í•©ë‹ˆë‹¤.
models.Base.metadata.create_all(bind=engine)

app = FastAPI(
    title="Tripot API",
    description="íŠ¸ë¼ì´íŒŸ ì„œë¹„ìŠ¤ì˜ í†µí•© API ì„œë²„ì…ë‹ˆë‹¤.",
    version="1.0.0"
)

# ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ì¶œì²˜ ëª©ë¡ì„ ëª…í™•í•˜ê²Œ ì •ì˜í•˜ì—¬ CORS ë¬¸ì œë¥¼ í•´ê²°í•©ë‹ˆë‹¤.
origins = [
    # ì‹¤ì œ ì•±/ì›¹ ì£¼ì†Œ (ì˜ˆì‹œ)
    # "http://tripot.com",
    # "https://tripot.com",

    # ë¡œì»¬ ê°œë°œ ë° í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•œ ì£¼ì†Œ
    "http://localhost",
    "http://localhost:8080", # Nginx
    "http://localhost:8889", # Backend Direct
    "null", # ë¡œì»¬ HTML íŒŒì¼ í…ŒìŠ¤íŠ¸ìš©
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# '/api/v1' ê²½ë¡œë¡œ ë“¤ì–´ì˜¤ëŠ” ëª¨ë“  ìš”ì²­ì„ api_routerì—ê²Œ ìœ„ì„í•©ë‹ˆë‹¤.
app.include_router(api_router, prefix="/api/v1")

# ì„œë²„ ìƒíƒœ í™•ì¸ìš© ë£¨íŠ¸ ê²½ë¡œ
@app.get("/", tags=["Default"])
def read_root():
    return {"message": "Welcome to Tripot Integrated Backend!"}










    import openai
import asyncio
import json
import os
import base64
import tempfile

from app.core.config import settings
# ìˆœí™˜ ì°¸ì¡°(Circular Dependency)ë¥¼ í”¼í•˜ê¸° ìœ„í•´, ì´ íŒŒì¼ì—ì„œëŠ” ë‹¤ë¥¸ ì„œë¹„ìŠ¤ íŒŒì¼ì„ ì§ì ‘ importí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

# OpenAI í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”
client = openai.OpenAI(api_key=settings.OPENAI_API_KEY)

# --- 1. Core AI Utilities (ê¸°ì¡´ê³¼ ìœ ì‚¬) ---

async def get_embedding(text: str) -> list[float]:
    """í…ìŠ¤íŠ¸ë¥¼ ë°›ì•„ ì„ë² ë”© ë²¡í„°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
    response = await asyncio.to_thread(
        client.embeddings.create, input=text, model="text-embedding-3-small"
    )
    return response.data[0].embedding

async def get_transcript_from_audio(audio_file_path: str) -> str:
    """ì˜¤ë””ì˜¤ íŒŒì¼ ê²½ë¡œë¥¼ ë°›ì•„ STT(Speech-to-Text) ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
    with open(audio_file_path, "rb") as audio_file:
        transcript_response = await asyncio.to_thread(
            client.audio.transcriptions.create, model="whisper-1", file=audio_file, language="ko"
        )
    return transcript_response.text

async def get_ai_chat_completion(prompt: str, model: str = "gpt-4o", max_tokens: int = 150, temperature: float = 0.7) -> str:
    """ì£¼ì–´ì§„ í”„ë¡¬í”„íŠ¸ì— ëŒ€í•œ AI ì±—ë´‡ì˜ ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤."""
    messages = [
        {"role": "system", "content": "ë‹¹ì‹ ì€ ì£¼ì–´ì§„ ê·œì¹™ê³¼ í˜ë¥´ì†Œë‚˜ë¥¼ ì™„ë²½í•˜ê²Œ ë”°ë¥´ëŠ” AI ì–´ì‹œìŠ¤í„´íŠ¸ì…ë‹ˆë‹¤."},
        {"role": "user", "content": prompt}
    ]
    chat_response = await asyncio.to_thread(
        client.chat.completions.create,
        model=model,
        messages=messages,
        max_tokens=max_tokens,
        temperature=temperature
    )
    return chat_response.choices[0].message.content

# --- 2. Main Real-time Conversation Logic (í•µì‹¬ ë¡œì§ ì´ë™) ---

def _load_talk_prompt():
    """prompts/talk_prompt.json íŒŒì¼ì„ ì•ˆì „í•˜ê²Œ ì½ì–´ì˜¤ëŠ” í—¬í¼ í•¨ìˆ˜"""
    prompt_file_path = os.path.join(os.path.dirname(__file__), '..', '..', 'prompts', 'talk_prompt.json')
    try:
        with open(prompt_file_path, 'r', encoding='utf-8') as f:
            return json.load(f)['main_chat_prompt']
    except Exception as e:
        print(f"âŒ talk_prompt.json íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: {e}")
        return None

PROMPTS_CONFIG = _load_talk_prompt()

async def process_user_audio(user_id: str, audio_base64: str):
    """
    ì‚¬ìš©ìì˜ ìŒì„± ë°ì´í„°ë¥¼ ë°›ì•„ ì²˜ë¦¬í•˜ê³ , AIì˜ ìµœì¢… ì‘ë‹µì„ ìƒì„±í•˜ëŠ” ì „ì²´ ê³¼ì •ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤.
    (ê¸°ì¡´ main.pyì˜ process_audio_and_get_response ë¡œì§ì„ ì´ê³³ìœ¼ë¡œ ì´ë™)
    """
    # ìˆœí™˜ ì°¸ì¡° ë°©ì§€ë¥¼ ìœ„í•´ í•„ìš”í•  ë•Œë§Œ vector_db_serviceë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
    from . import vector_db

    audio_data = base64.b64decode(audio_base64)
    with tempfile.NamedTemporaryFile(delete=False, suffix=".wav") as temp_audio:
        temp_audio.write(audio_data)
        temp_audio_path = temp_audio.name
    
    try:
        user_message = await get_transcript_from_audio(temp_audio_path)
        if not user_message.strip() or "ì‹œì²­í•´ì£¼ì…”ì„œ ê°ì‚¬í•©ë‹ˆë‹¤" in user_message:
            return None, "ìŒ, ì˜ ì•Œì•„ë“£ì§€ ëª»í–ˆì–´ìš”. í˜¹ì‹œ ë‹¤ì‹œ í•œë²ˆ ë§ì”€í•´ì£¼ì‹œê² ì–´ìš”?"
        
        relevant_memories = await vector_db.search_memories(user_id, user_message)
        
        if not PROMPTS_CONFIG:
            return user_message, "ëŒ€í™” í”„ë¡¬í”„íŠ¸ ì„¤ì • íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ì–´ ê¸°ë³¸ ì‘ë‹µì„ ë“œë¦½ë‹ˆë‹¤."

        system_message = "\n".join(PROMPTS_CONFIG['system_message_base'])
        examples_text = "\n\n".join([f"ìƒí™©: {ex['situation']}\nì‚¬ìš©ì ì…ë ¥: {ex['user_input']}\nAI ì‘ë‹µ: {ex['ai_response']}" for ex in PROMPTS_CONFIG['examples']])
        
        final_prompt = f"""# í˜ë¥´ì†Œë‚˜\n{system_message}\n# í•µì‹¬ ëŒ€í™” ê·œì¹™\n{"\n".join(PROMPTS_CONFIG['core_conversation_rules'])}\n# ì‘ë‹µ ê°€ì´ë“œë¼ì¸\n{"\n".join(PROMPTS_CONFIG['guidelines_and_reactions'])}\n# ì ˆëŒ€ ê¸ˆì§€ì‚¬í•­\n{"\n".join(PROMPTS_CONFIG['strict_prohibitions'])}\n# ì„±ê³µì ì¸ ëŒ€í™” ì˜ˆì‹œ\n{examples_text}\n---\nì´ì œ ì‹¤ì œ ëŒ€í™”ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.\n--- ê³¼ê±° ëŒ€í™” í•µì‹¬ ê¸°ì–µ ---\n{relevant_memories if relevant_memories else "ì´ì „ ëŒ€í™” ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤."}\n--------------------\ní˜„ì¬ ì‚¬ìš©ì ë©”ì‹œì§€: "{user_message}"\nAI ë‹µë³€:"""
        
        ai_response = await get_ai_chat_completion(final_prompt)
        
        return user_message, ai_response
    finally:
        os.unlink(temp_audio_path)

# --- 3. Report Generation Logic (for background scripts) ---

def _get_report_prompt():
    """prompts/report_prompt.json íŒŒì¼ì„ ì½ì–´ì˜¤ëŠ” í—¬í¼ í•¨ìˆ˜"""
    prompt_file_path = os.path.join(os.path.dirname(__file__), '..', '..', 'prompts', 'report_prompt.json')
    try:
        with open(prompt_file_path, 'r', encoding='utf-8') as f:
            return json.load(f).get("report_analysis_prompt")
    except Exception as e:
        print(f"âŒ report_prompt.json íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: {e}")
        return None

def generate_summary_report(conversation_text: str) -> dict | None:
    """ëŒ€í™” ë‚´ìš©ì„ ë¶„ì„í•˜ì—¬ JSON í˜•ì‹ì˜ ë¦¬í¬íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤ (ë™ê¸° ë°©ì‹)."""
    
    report_prompt_template = _get_report_prompt()
    if not conversation_text or not report_prompt_template:
        return None

    persona = report_prompt_template.get('persona', 'ë‹¹ì‹ ì€ ì „ë¬¸ ëŒ€í™” ë¶„ì„ AIì…ë‹ˆë‹¤.')
    instructions = "\n".join(report_prompt_template.get('instructions', []))
    output_format_example = json.dumps(report_prompt_template.get('OUTPUT_FORMAT', {}), ensure_ascii=False, indent=2)

    system_prompt = f"{persona}\n\n### ì§€ì‹œì‚¬í•­\n{instructions}\n\n### ì¶œë ¥ í˜•ì‹\nëª¨ë“  ê²°ê³¼ëŠ” ì•„ë˜ì™€ ê°™ì€ JSON í˜•ì‹ìœ¼ë¡œë§Œ ì¶œë ¥í•´ì•¼ í•©ë‹ˆë‹¤. ì¶”ê°€ ì„¤ëª…ì´ë‚˜ ì¸ì‚¬ë§ ë“± JSON ì™¸ì˜ í…ìŠ¤íŠ¸ëŠ” ì ˆëŒ€ í¬í•¨í•˜ì§€ ë§ˆì„¸ìš”.\n{output_format_example}"
    user_prompt = f"### ë¶„ì„í•  ëŒ€í™” ì „ë¬¸\n---\n{conversation_text}\n---"

    try:
        completion = client.chat.completions.create(
            model="gpt-4o", 
            response_format={"type": "json_object"},
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ]
        )
        return json.loads(completion.choices[0].message.content)
    except Exception as e:
        print(f"AI ë¦¬í¬íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        return None



---------------------------------------------------------------------------------------

// @ts-nocheck
import PushNotification, { Importance } from 'react-native-push-notification';
import { PermissionsAndroid, Alert, Platform, AppState } from 'react-native';

interface NotificationUserInfo {
  action: string;
  scheduled_time?: string;
  user_id?: string;
}

class RealNotificationManager {
  private setScreenFunction: ((screen: string) => void) | null = null;

  constructor() {
    this.initializeNotifications();
  }

  // setCurrentScreen í•¨ìˆ˜ ì„¤ì •
  setScreen(setScreenFunc: (screen: string) => void): void {
    this.setScreenFunction = setScreenFunc;
    console.log('ğŸ¯ setCurrentScreen í•¨ìˆ˜ ì„¤ì •ë¨');
  }

  // ì•Œë¦¼ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
  private initializeNotifications(): void {
    PushNotification.configure({
      // ì•Œë¦¼ í„°ì¹˜ ì‹œ ì‹¤í–‰ (ì•±ì´ êº¼ì ¸ìˆì–´ë„ ì‹¤í–‰ë¨!)
      onNotification: (notification: any) => {
        console.log('ğŸ“± í‘¸ì‹œ ì•Œë¦¼ í„°ì¹˜ë¨:', JSON.stringify(notification, null, 2));
        console.log('ğŸ“± ì•¡ì…˜:', notification.action);
        console.log('ğŸ“± ì‚¬ìš©ì ì •ë³´:', notification.userInfo);
        console.log('ğŸ“± data:', notification.data);
        
        // ì•¡ì…˜ ë²„íŠ¼ì´ ëˆŒë¦° ê²½ìš°
        if (notification.action) {
          console.log('ğŸ”¥ ì•¡ì…˜ ë²„íŠ¼ í´ë¦­ë¨:', notification.action);
          if (notification.action === 'ì§€ê¸ˆëŒ€í™”') {
            console.log('ğŸ¯ ì§€ê¸ˆ ëŒ€í™”í•˜ê¸° - ë§í•˜ê¸° í™”ë©´ìœ¼ë¡œ ì´ë™');
            this.navigateToSpeakScreen();
            return;
          } else if (notification.action === '10ë¶„í›„') {
            console.log('â° 10ë¶„ í›„ - ìŠ¤ëˆ„ì¦ˆ ì•ŒëŒ ì„¤ì •');
            this.snoozeAlarm(10);
            return;
          } else if (notification.action === 'ê±´ë„ˆë›°ê¸°') {
            console.log('âŒ ê±´ë„ˆë›°ê¸° - ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠìŒ');
            return;
          }
        }
        
        // ì •ì‹œ ëŒ€í™” ì•Œë¦¼ì¸ ê²½ìš° (ì•Œë¦¼ ìì²´ë¥¼ í„°ì¹˜í•œ ê²½ìš°)
        if (notification.data?.action === 'scheduled_call' || notification.userInfo?.action === 'scheduled_call') {
          console.log('ğŸ“ ì •ì‹œ ëŒ€í™” ì•Œë¦¼ í„°ì¹˜ - ì¦‰ì‹œ ë‹¤ì´ì–¼ë¡œê·¸ í‘œì‹œ');
          // ì¦‰ì‹œ ë‹¤ì´ì–¼ë¡œê·¸ í‘œì‹œ (ë”œë ˆì´ ì—†ì´)
          this.showCallDialog(notification.data?.scheduled_time || notification.userInfo?.scheduled_time);
        }
        
        // ì•Œë¦¼ ì²˜ë¦¬ ì™„ë£Œ í‘œì‹œ (ì¤‘ìš”!)
        if (notification.finish) {
          notification.finish(PushNotification.FetchResult.NoData);
        }
      },

      // ì•¡ì…˜ ë²„íŠ¼ ì²˜ë¦¬
      onAction: (notification: any) => {
        console.log('ğŸš€ğŸš€ğŸš€ onAction ì½œë°± ì‹¤í–‰ë¨!');
        console.log('ğŸ“± ì•Œë¦¼ ì•¡ì…˜ ì „ì²´:', JSON.stringify(notification, null, 2));
        console.log('ğŸ“± ì•¡ì…˜:', notification.action);
        console.log('ğŸ“± ì‚¬ìš©ì ì •ë³´:', notification.userInfo);
        
        // ì•Œë¦¼ìœ¼ë¡œë„ ì•Œë ¤ì£¼ê¸°
        Alert.alert('ì•¡ì…˜ ë²„íŠ¼ í´ë¦­ë¨', `ì•¡ì…˜: ${notification.action}`);
        
        // ì•¡ì…˜ ë²„íŠ¼ ì²˜ë¦¬ (ë„ì–´ì“°ê¸° ì—†ëŠ” ë¬¸ìì—´)
        if (notification.action === 'ì§€ê¸ˆëŒ€í™”') {
          console.log('ğŸ¯ ì§€ê¸ˆ ëŒ€í™”í•˜ê¸° ì•¡ì…˜ ì‹¤í–‰');
          this.navigateToSpeakScreen();
        } else if (notification.action === '10ë¶„í›„') {
          console.log('â° 10ë¶„ í›„ ì•¡ì…˜ ì‹¤í–‰');
          this.snoozeAlarm(10);
        } else if (notification.action === 'ê±´ë„ˆë›°ê¸°') {
          console.log('âŒ ê±´ë„ˆë›°ê¸° ì•¡ì…˜ ì‹¤í–‰');
          // ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠìŒ
        } else if (notification.action === 'ëŒ€í™”í•˜ê¸°') {
          console.log('ğŸ¯ ëŒ€í™”í•˜ê¸° ì•¡ì…˜ ì‹¤í–‰ (ìŠ¤ëˆ„ì¦ˆì—ì„œ)');
          this.navigateToSpeakScreen();
        } else if (notification.action === 'ë‹¤ì‹œì—°ê¸°') {
          console.log('â° ë‹¤ì‹œ ì—°ê¸° ì•¡ì…˜ ì‹¤í–‰');
          this.snoozeAlarm(10);
        } else {
          console.log('ğŸ¤· ì•Œ ìˆ˜ ì—†ëŠ” ì•¡ì…˜:', notification.action);
        }
      },

      // í† í° ë“±ë¡ (FCMìš© - ë‚˜ì¤‘ì— ì‚¬ìš©)
      onRegister: (token: any) => {
        console.log('ğŸ“± í‘¸ì‹œ í† í°:', token);
      },

      // ê¶Œí•œ
      permissions: {
        alert: true,
        badge: true,
        sound: true,
      },

      // ì´ˆê¸° ì•Œë¦¼ ì²˜ë¦¬
      popInitialNotification: true,
      requestPermissions: Platform.OS === 'ios',
    });

    // ì•Œë¦¼ ì±„ë„ ìƒì„± (Android)
    this.createNotificationChannel();
  }

  // ì•Œë¦¼ ì±„ë„ ìƒì„±
  private createNotificationChannel(): void {
    PushNotification.createChannel(
      {
        channelId: 'default-channel-id',
        channelName: 'ê¸°ë³¸ ì•Œë¦¼',
        channelDescription: 'ì•±ì˜ ê¸°ë³¸ ì•Œë¦¼ ì±„ë„',
        playSound: true,
        soundName: 'alarm.mp3', // ì»¤ìŠ¤í…€ ì•ŒëŒ ì†Œë¦¬
        importance: Importance.HIGH,
        vibrate: true,
      },
      (created: boolean) => {
        console.log(`âœ… ê¸°ë³¸ ì•Œë¦¼ ì±„ë„ ìƒì„±: ${created}`);
        
        // ì¶”ê°€ ì±„ë„ë„ ìƒì„±
        PushNotification.createChannel(
          {
            channelId: 'scheduled-call-high',
            channelName: 'ì •ì‹œ ëŒ€í™” ì•Œë¦¼',
            channelDescription: 'ì„¤ì •í•œ ì‹œê°„ì— ìš¸ë¦¬ëŠ” ëŒ€í™” ì•Œë¦¼',
            playSound: true,
            soundName: 'alarm.mp3', // ì»¤ìŠ¤í…€ ì•ŒëŒ ì†Œë¦¬
            importance: Importance.HIGH,
            vibrate: true,
          },
          (created2: boolean) => {
            console.log(`âœ… ì •ì‹œ ëŒ€í™” ì•Œë¦¼ ì±„ë„ ìƒì„±: ${created2}`);
          }
        );
      }
    );
  }

  // ê¶Œí•œ ìš”ì²­
  async requestPermissions(): Promise<boolean> {
    try {
      if (Platform.OS === 'android') {
        const granted = await PermissionsAndroid.request(
          PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS,
          {
            title: 'ğŸ”” ì•Œë¦¼ ê¶Œí•œ í•„ìš”',
            message: 'ì •ì‹œ ëŒ€í™” ì•Œë¦¼ì„ ë°›ê¸° ìœ„í•´ ì•Œë¦¼ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.\n\nì•±ì´ êº¼ì ¸ìˆì–´ë„ ì•Œë¦¼ì´ ìš¸ë¦½ë‹ˆë‹¤!',
            buttonPositive: 'í—ˆìš©',
            buttonNegative: 'ê±°ë¶€',
          }
        );
        return granted === PermissionsAndroid.RESULTS.GRANTED;
      }
      return true;
    } catch (err) {
      console.warn('ê¶Œí•œ ìš”ì²­ ì˜¤ë¥˜:', err);
      return false;
    }
  }

  // ì •ì‹œ ëŒ€í™” ìŠ¤ì¼€ì¤„ ì„¤ì • (ì§„ì§œ í‘¸ì‹œ ì•Œë¦¼)
  scheduleConversationAlarm(times: string[]): void {
    console.log('ğŸš€ scheduleConversationAlarm í˜¸ì¶œë¨:', times);
    
    // ê¸°ì¡´ ì˜ˆì•½ëœ ì•Œë¦¼ ëª¨ë‘ ì·¨ì†Œ
    PushNotification.cancelAllLocalNotifications();
    console.log('âœ… ê¸°ì¡´ ì•Œë¦¼ ëª¨ë‘ ì·¨ì†Œë¨');

    times.forEach((time: string, index: number) => {
      const [hours, minutes] = time.split(':').map(Number);
      const scheduledDate = this.getNextScheduledTime(hours, minutes);
      
      console.log(`â° ìŠ¤ì¼€ì¤„ ${index + 1}: ${time} â†’ ${scheduledDate.toString()}`);

      // ì§„ì§œ í‘¸ì‹œ ì•Œë¦¼ ìŠ¤ì¼€ì¤„ë§ (ì•±ì´ êº¼ì ¸ìˆì–´ë„ ì‘ë™!)
      PushNotification.localNotificationSchedule({
        id: 1000 + index, // ìˆ«ì ID ì‚¬ìš©
        channelId: 'scheduled-call-high',
        
        // ì•Œë¦¼ ë‚´ìš©
        title: 'ğŸ“ ì •ì‹œ ëŒ€í™” ì‹œê°„ì´ì—ìš”!',
        message: 'ë§ë²—ê³¼ ëŒ€í™”ë¥¼ ì‹œì‘í•˜ì‹œê² ì–´ìš”? í„°ì¹˜í•´ì„œ ì•±ì„ ì—´ì–´ë³´ì„¸ìš”.',
        bigText: 'ì„¤ì •í•˜ì‹  ì •ì‹œ ëŒ€í™” ì‹œê°„ì…ë‹ˆë‹¤. ì§€ê¸ˆ ë°”ë¡œ ëŒ€í™”ë¥¼ ì‹œì‘í•˜ê±°ë‚˜ 10ë¶„ í›„ë¡œ ì—°ê¸°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
        
        // ì‹œê°„ ì„¤ì •
        date: scheduledDate,
        repeatType: 'day',
        
        // ì†Œë¦¬ ë° ì§„ë™ (ê°•ë ¥í•˜ê²Œ!)
        playSound: true,
        soundName: 'alarm.mp3', // ì»¤ìŠ¤í…€ ì•ŒëŒ ì†Œë¦¬
        vibrate: true,
        vibration: 2000,
        
        // ë†’ì€ ìš°ì„ ìˆœìœ„
        importance: 'high',
        priority: 'high',
        
        // ì ê¸ˆ í™”ë©´ì—ì„œë„ í‘œì‹œ
        visibility: 'public',
        
        // ì•± ì•„ì´ì½˜ ë±ƒì§€
        number: 1,
        
        // ì•¡ì…˜ ë²„íŠ¼ë“¤ (ë„ì–´ì“°ê¸° ì—†ìŒ)
        actions: ['ì§€ê¸ˆëŒ€í™”', '10ë¶„í›„', 'ê±´ë„ˆë›°ê¸°'],
        
        // ì‚¬ìš©ì ë°ì´í„°
        userInfo: {
          action: 'scheduled_call',
          scheduled_time: time,
          user_id: 'user_1752303760586_8wi64r'
        } as NotificationUserInfo,

        // Android ì „ìš© ì„¤ì •
        autoCancel: true,
        largeIcon: 'ic_launcher',
        smallIcon: 'ic_notification',
        color: '#007AFF',
        ongoing: false,
      });

      console.log(`âœ… ${time} ì§„ì§œ í‘¸ì‹œ ì•Œë¦¼ ì„¤ì • ì™„ë£Œ (ID: ${1000 + index})`);
    });
    
    console.log(`ğŸ¯ ì´ ${times.length}ê°œ ì§„ì§œ í‘¸ì‹œ ì•Œë¦¼ ì„¤ì • ì™„ë£Œ`);
  }

  // ë‹¤ìŒ ìŠ¤ì¼€ì¤„ ì‹œê°„ ê³„ì‚°
  private getNextScheduledTime(hours: number, minutes: number): Date {
    const now = new Date();
    const scheduledTime = new Date();
    
    scheduledTime.setHours(hours, minutes, 0, 0);
    
    // ì˜¤ëŠ˜ ì‹œê°„ì´ ì§€ë‚¬ìœ¼ë©´ ë‚´ì¼ë¡œ ì„¤ì •
    if (scheduledTime <= now) {
      scheduledTime.setDate(scheduledTime.getDate() + 1);
    }
    
    return scheduledTime;
  }

  // ì¦‰ì‹œ í…ŒìŠ¤íŠ¸ (ì§„ì§œ í‘¸ì‹œ ì•Œë¦¼)
  testImmediateNotification(): void {
    console.log('ğŸš€ ì¦‰ì‹œ í‘¸ì‹œ ì•Œë¦¼ í…ŒìŠ¤íŠ¸ ì‹œì‘');
    
    // ë¨¼ì € ì¦‰ì‹œ ì•Œë¦¼ ì‹œë„
    PushNotification.localNotification({
      channelId: 'default-channel-id',
      title: 'âš¡ ì¦‰ì‹œ í…ŒìŠ¤íŠ¸ ì•Œë¦¼',
      message: 'ì¦‰ì‹œ ì•Œë¦¼ì´ í‘œì‹œë˜ì—ˆìŠµë‹ˆë‹¤!',
      playSound: true,
      soundName: 'alarm.mp3', // ì»¤ìŠ¤í…€ ì•ŒëŒ ì†Œë¦¬
      vibrate: true,
      vibration: 3000,
      importance: 'high',
      priority: 'high',
      userInfo: { action: 'immediate_test' } as NotificationUserInfo,
    });
    
    console.log('âœ… ì¦‰ì‹œ ì•Œë¦¼ ì„¤ì • ì™„ë£Œ');
    
    // 5ì´ˆ í›„ì— ë‹¤ì‹œ ì¦‰ì‹œ ì•Œë¦¼ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ (ìŠ¤ì¼€ì¤„ ëŒ€ì‹ )
    setTimeout(() => {
      console.log('ğŸ• 5ì´ˆ í›„ ì¦‰ì‹œ ì•Œë¦¼ ì‹¤í–‰');
      PushNotification.localNotification({
        channelId: 'default-channel-id',
        title: 'âš¡ 5ì´ˆ í›„ ì¦‰ì‹œ ì•Œë¦¼',
        message: 'ì´ê²ƒë„ ì¦‰ì‹œ ì•Œë¦¼ì…ë‹ˆë‹¤!',
        playSound: true,
        soundName: 'alarm.mp3', // ì»¤ìŠ¤í…€ ì•ŒëŒ ì†Œë¦¬
        vibrate: true,
        vibration: 3000,
        importance: 'high',
        priority: 'high',
        userInfo: { action: 'delayed_immediate_test' } as NotificationUserInfo,
      });
    }, 5000);
    
    Alert.alert('ì¦‰ì‹œ + 5ì´ˆ í›„ í…ŒìŠ¤íŠ¸', 'ì¦‰ì‹œ ì•Œë¦¼ì´ ë‚˜íƒ€ë‚¬ê³ , 5ì´ˆ í›„ì— ë˜ ë‹¤ë¥¸ ì¦‰ì‹œ ì•Œë¦¼ì´ ìš¸ë¦½ë‹ˆë‹¤!');
  }

  // 1ë¶„ í›„ í…ŒìŠ¤íŠ¸ (setTimeout ì‚¬ìš©)
  testNotification(): void {
    console.log('ğŸ§ª 1ë¶„ í›„ í‘¸ì‹œ ì•Œë¦¼ í…ŒìŠ¤íŠ¸ ì‹œì‘ (setTimeout ì‚¬ìš©)');
    
    Alert.alert('1ë¶„ í…ŒìŠ¤íŠ¸ ì‹œì‘', '1ë¶„ í›„ì— ì¦‰ì‹œ ì•Œë¦¼ì´ ìš¸ë¦½ë‹ˆë‹¤!\n(ìŠ¤ì¼€ì¤„ ëŒ€ì‹  setTimeout ì‚¬ìš©)');
    
    // setTimeoutì„ ì‚¬ìš©í•´ì„œ 1ë¶„ í›„ì— ì¦‰ì‹œ ì•Œë¦¼
    setTimeout(() => {
      console.log('ğŸ• 1ë¶„ í›„ ì¦‰ì‹œ ì•Œë¦¼ ì‹¤í–‰');
      PushNotification.localNotification({
        channelId: 'default-channel-id',
        title: 'ğŸ§ª 1ë¶„ í›„ í…ŒìŠ¤íŠ¸ ì„±ê³µ!',
        message: 'setTimeoutìœ¼ë¡œ 1ë¶„ í›„ ì¦‰ì‹œ ì•Œë¦¼ì…ë‹ˆë‹¤!',
        playSound: true,
        soundName: 'alarm.mp3', // ì»¤ìŠ¤í…€ ì•ŒëŒ ì†Œë¦¬
        vibrate: true,
        vibration: 2000,
        importance: 'high',
        priority: 'high',
        userInfo: { action: 'timeout_test' } as NotificationUserInfo,
      });
    }, 60000); // 60ì´ˆ = 1ë¶„
    
    console.log('âœ… 1ë¶„ í›„ setTimeout ì•Œë¦¼ ì„¤ì • ì™„ë£Œ');
  }

  // ê°„ë‹¨í•œ ìŠ¤ì¼€ì¤„ í…ŒìŠ¤íŠ¸ (10ì´ˆ í›„)
  testSimpleSchedule(): void {
    console.log('â° ê°„ë‹¨í•œ 10ì´ˆ ìŠ¤ì¼€ì¤„ í…ŒìŠ¤íŠ¸');
    
    const testTime = new Date();
    testTime.setSeconds(testTime.getSeconds() + 10);
    
    console.log('ì˜ˆì•½ ì‹œê°„:', testTime.toString());
    
    PushNotification.localNotificationSchedule({
      id: 2001, // ìˆ«ì ID
      title: 'â° 10ì´ˆ ìŠ¤ì¼€ì¤„ í…ŒìŠ¤íŠ¸',
      message: '10ì´ˆ í›„ ìŠ¤ì¼€ì¤„ ì•Œë¦¼ì…ë‹ˆë‹¤!',
      date: testTime,
      playSound: true,
      soundName: 'alarm.mp3', // ì»¤ìŠ¤í…€ ì•ŒëŒ ì†Œë¦¬
      vibrate: true,
      userInfo: { action: 'simple_schedule_test' } as NotificationUserInfo,
    });
    
    console.log('âœ… 10ì´ˆ ìŠ¤ì¼€ì¤„ ì•Œë¦¼ ì„¤ì • ì™„ë£Œ');
    Alert.alert('10ì´ˆ ìŠ¤ì¼€ì¤„ í…ŒìŠ¤íŠ¸', '10ì´ˆ í›„ì— ìŠ¤ì¼€ì¤„ ì•Œë¦¼ì´ ìš¸ë¦½ë‹ˆë‹¤!');
  }

  // í‘¸ì‹œ ì•Œë¦¼ í„°ì¹˜ ì‹œ ì²˜ë¦¬
  private handleScheduledCallNotification(notification: any): void {
    console.log('ğŸ“ ì •ì‹œ ëŒ€í™” ì•Œë¦¼ ì²˜ë¦¬:', notification);
    
    // ì•±ì´ í¬ê·¸ë¼ìš´ë“œì— ìˆìœ¼ë©´ ì¦‰ì‹œ ë‹¤ì´ì–¼ë¡œê·¸
    if (AppState.currentState === 'active') {
      this.showCallDialog(notification.userInfo?.scheduled_time);
    } else {
      // ì•±ì´ ë°±ê·¸ë¼ìš´ë“œ/ì¢…ë£Œ ìƒíƒœë©´ ì•±ì„ ì—´ê³  ë‹¤ì´ì–¼ë¡œê·¸
      this.bringAppToForegroundAndShowDialog(notification.userInfo?.scheduled_time);
    }
  }

  // ëŒ€í™” ë‹¤ì´ì–¼ë¡œê·¸ í‘œì‹œ
  private showCallDialog(scheduledTime?: string): void {
    Alert.alert(
      'ğŸ“ ì •ì‹œ ëŒ€í™” ì‹œê°„ì´ì—ìš”!',
      scheduledTime ? `${this.formatTime(scheduledTime)}ì— ì˜ˆì •ëœ ëŒ€í™” ì‹œê°„ì…ë‹ˆë‹¤.` : 'ì§€ê¸ˆ ëŒ€í™”ë¥¼ ì‹œì‘í•˜ì‹œê² ì–´ìš”?',
      [
        {
          text: 'ì§€ê¸ˆ ëŒ€í™”í•˜ê¸°',
          onPress: () => {
            console.log('ì •ì‹œ ëŒ€í™” - ë§í•˜ê¸° í™”ë©´ìœ¼ë¡œ ì´ë™');
            this.navigateToSpeakScreen();
          }
        },
        {
          text: '10ë¶„ í›„ì—',
          onPress: () => this.snoozeAlarm(10)
        },
        {
          text: 'ê±´ë„ˆë›°ê¸°',
          style: 'cancel'
        }
      ]
    );
  }

  // ì•±ì„ í¬ê·¸ë¼ìš´ë“œë¡œ ê°€ì ¸ì˜¤ê³  ë‹¤ì´ì–¼ë¡œê·¸ í‘œì‹œ
  private bringAppToForegroundAndShowDialog(scheduledTime?: string): void {
    // ì ì‹œ í›„ ë‹¤ì´ì–¼ë¡œê·¸ í‘œì‹œ (ì•±ì´ ì™„ì „íˆ ë¡œë“œë  ì‹œê°„ í™•ë³´)
    setTimeout(() => {
      this.showCallDialog(scheduledTime);
    }, 1000);
  }

  // ë§í•˜ê¸° í™”ë©´ìœ¼ë¡œ ì´ë™
  private navigateToSpeakScreen(): void {
    console.log('ğŸ¯ğŸ¯ğŸ¯ navigateToSpeakScreen í˜¸ì¶œë¨!');
    console.log('setScreenFunction ìƒíƒœ:', this.setScreenFunction);
    
    if (this.setScreenFunction) {
      console.log('âœ… ë§í•˜ê¸° í™”ë©´ìœ¼ë¡œ ì´ë™ ì‹¤í–‰');
      this.setScreenFunction('Speak');
      console.log('âœ… setScreenFunction(Speak) í˜¸ì¶œ ì™„ë£Œ');
      
      // ì¶”ê°€ë¡œ Alertë„ í‘œì‹œí•´ì„œ í™•ì‹¤íˆ í™•ì¸
      setTimeout(() => {
        Alert.alert('í™”ë©´ ì´ë™', 'ë§í•˜ê¸° í™”ë©´ìœ¼ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤!');
      }, 500);
    } else {
      console.error('âš ï¸âš ï¸âš ï¸ setCurrentScreen í•¨ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ');
      Alert.alert('ì˜¤ë¥˜', 'setCurrentScreen í•¨ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
    }
  }

  // ìŠ¤ëˆ„ì¦ˆ (10ë¶„ í›„ ë‹¤ì‹œ ì•Œë¦¼)
  private snoozeAlarm(minutes: number): void {
    const snoozeTime = new Date();
    snoozeTime.setMinutes(snoozeTime.getMinutes() + minutes);

    PushNotification.localNotificationSchedule({
      id: 3001, // ìˆ«ì ID
      channelId: 'scheduled-call-high',
      title: 'ğŸ”” ì—°ê¸°ëœ ëŒ€í™” ì‹œê°„',
      message: 'ì´ì œ ëŒ€í™”ë¥¼ ì‹œì‘í•´ë³¼ê¹Œìš”?',
      date: snoozeTime,
      playSound: true,
      soundName: 'alarm.mp3', // ì»¤ìŠ¤í…€ ì•ŒëŒ ì†Œë¦¬
      vibrate: true,
      vibration: 2000,
      importance: 'high',
      priority: 'high',
      actions: ['ëŒ€í™”í•˜ê¸°', 'ë‹¤ì‹œì—°ê¸°'], // ë„ì–´ì“°ê¸° ì—†ìŒ
      userInfo: { action: 'snooze_call' } as NotificationUserInfo,
    });

    Alert.alert('ì•Œë¦¼ ì—°ê¸°', `${minutes}ë¶„ í›„ì— ë‹¤ì‹œ ì•Œë ¤ë“œë¦´ê²Œìš”`);
  }

  // ì‹œê°„ í˜•ì‹ ë³€í™˜
  private formatTime(timeStr: string): string {
    const [hours, minutes] = timeStr.split(':');
    const hour = parseInt(hours);
    const ampm = hour >= 12 ? 'ì˜¤í›„' : 'ì˜¤ì „';
    const displayHour = hour > 12 ? hour - 12 : hour === 0 ? 12 : hour;
    return `${ampm} ${displayHour}:${minutes}`;
  }

  // ëª¨ë“  ì•Œë¦¼ ì·¨ì†Œ
  cancelAllNotifications(): void {
    PushNotification.cancelAllLocalNotifications();
    console.log('ëª¨ë“  í‘¸ì‹œ ì•Œë¦¼ ì·¨ì†Œë¨');
  }

  // ê¶Œí•œ í™•ì¸
  async checkPermissions(): Promise<boolean> {
    try {
      if (Platform.OS === 'android') {
        const result = await PermissionsAndroid.check(
          PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS
        );
        console.log('í˜„ì¬ ê¶Œí•œ ìƒíƒœ:', result);
        return result;
      }
      return true;
    } catch (err) {
      console.warn('ê¶Œí•œ í™•ì¸ ì˜¤ë¥˜:', err);
      return false;
    }
  }
}

export default new RealNotificationManager();

------------------------------------------------------------------------------------

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  SafeAreaView,
  Switch,
  Alert
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import NotificationManager from '../utils/RealNotificationManager';

interface Schedule {
  id: number;
  call_time: string;
  is_enabled: boolean;
  created_at: string;
}

interface TimeOption {
  time: string;
  label: string;
}

interface SettingScreenProps {
  navigation: { 
    goBack: () => void; 
  };
  userId: string;
  apiBaseUrl: string;
}

const SettingScreen: React.FC<SettingScreenProps> = ({ navigation, userId, apiBaseUrl }) => {
  const [schedules, setSchedules] = useState<Schedule[]>([]);
  const [selectedTimes, setSelectedTimes] = useState<string[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(false);

  // ë‹¤ì–‘í•œ ì‹œê°„ ì˜µì…˜ë“¤ (ë³µìˆ˜ ì„ íƒ ê°€ëŠ¥)
  const timeOptions: TimeOption[] = [
    { time: '07:00', label: 'ì˜¤ì „ 7ì‹œ (ì•„ì¹¨ ì¼ì°)' },
    { time: '08:00', label: 'ì˜¤ì „ 8ì‹œ (ì•„ì¹¨)' },
    { time: '09:00', label: 'ì˜¤ì „ 9ì‹œ' },
    { time: '10:00', label: 'ì˜¤ì „ 10ì‹œ' },
    { time: '11:00', label: 'ì˜¤ì „ 11ì‹œ' },
    { time: '12:00', label: 'ì˜¤í›„ 12ì‹œ (ì ì‹¬)' },
    { time: '13:00', label: 'ì˜¤í›„ 1ì‹œ' },
    { time: '14:00', label: 'ì˜¤í›„ 2ì‹œ' },
    { time: '15:00', label: 'ì˜¤í›„ 3ì‹œ' },
    { time: '16:19', label: 'ì˜¤í›„ 4ì‹œ' },
    { time: '17:00', label: 'ì˜¤í›„ 5ì‹œ' },
    { time: '18:00', label: 'ì˜¤í›„ 6ì‹œ' },
    { time: '19:00', label: 'ì˜¤í›„ 7ì‹œ (ì €ë…)' },
    { time: '20:00', label: 'ì˜¤í›„ 8ì‹œ' },
    { time: '21:00', label: 'ì˜¤í›„ 9ì‹œ' },
  ];

  useEffect(() => {
    loadUserSchedules();
    // ì•Œë¦¼ ê¶Œí•œ ìš”ì²­
    requestNotificationPermissions();
  }, []);

  // ì•Œë¦¼ ê¶Œí•œ ìš”ì²­ ë° í™•ì¸
  const requestNotificationPermissions = async () => {
    try {
      // ë¨¼ì € í˜„ì¬ ê¶Œí•œ ìƒíƒœ í™•ì¸
      const hasPermission = await NotificationManager.checkPermissions();
      
      if (hasPermission) {
        console.log('âœ… ì•Œë¦¼ ê¶Œí•œì´ ì´ë¯¸ í—ˆìš©ë¨');
        return true;
      }

      // ê¶Œí•œ ìš”ì²­
      const granted = await NotificationManager.requestPermissions();
      
      if (granted) {
        console.log('âœ… ì•Œë¦¼ ê¶Œí•œ í—ˆìš©ë¨');
        Alert.alert(
          'ê¶Œí•œ í—ˆìš© ì™„ë£Œ',
          'ì´ì œ ì •ì‹œ ëŒ€í™” ì•Œë¦¼ì„ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤!',
          [{ text: 'í™•ì¸' }]
        );
        return true;
      } else {
        console.log('âŒ ì•Œë¦¼ ê¶Œí•œ ê±°ë¶€ë¨');
        Alert.alert(
          'ì•Œë¦¼ ê¶Œí•œ í•„ìš”',
          'ì •ì‹œ ëŒ€í™” ì•Œë¦¼ì„ ë°›ìœ¼ë ¤ë©´ ì„¤ì •ì—ì„œ ì•Œë¦¼ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.\n\nì„¤ì • > ì•± > íŠ¸ë¦¬íŒŸ > ì•Œë¦¼',
          [
            { text: 'ë‚˜ì¤‘ì—' },
            { 
              text: 'ì„¤ì •ìœ¼ë¡œ ì´ë™', 
              onPress: () => {
                // ì„¤ì • ì•±ìœ¼ë¡œ ì´ë™í•˜ëŠ” ë¡œì§ ì¶”ê°€ ê°€ëŠ¥
                console.log('ì„¤ì • ì•±ìœ¼ë¡œ ì´ë™ í•„ìš”');
              }
            }
          ]
        );
        return false;
      }
    } catch (error) {
      console.error('ê¶Œí•œ ìš”ì²­ ì‹¤íŒ¨:', error);
      return false;
    }
  };

  // ì‚¬ìš©ì ìŠ¤ì¼€ì¤„ ì¡°íšŒ
  const loadUserSchedules = async (): Promise<void> => {
    try {
      console.log('ğŸ“‹ ìŠ¤ì¼€ì¤„ ì¡°íšŒ ìš”ì²­');
      
      const response = await fetch(`${apiBaseUrl}/api/v1/schedule/${userId}`);
      const result = await response.json();

      if (response.ok) {
        console.log('âœ… ìŠ¤ì¼€ì¤„ ì¡°íšŒ ì„±ê³µ:', result);
        setSchedules(result.schedules);
        
        // ë¡œì»¬ ì €ì¥
        await AsyncStorage.setItem('userSchedules', JSON.stringify(result.schedules));
      } else {
        console.error('âŒ ìŠ¤ì¼€ì¤„ ì¡°íšŒ ì‹¤íŒ¨:', result);
      }
    } catch (error) {
      console.error('âŒ ìŠ¤ì¼€ì¤„ ì¡°íšŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜:', error);
    }
  };

  // ì‹œê°„ ì„ íƒ í† ê¸€ (ë³µìˆ˜ ì„ íƒ ê°€ëŠ¥)
  const toggleTimeSelection = (time: string): void => {
    setSelectedTimes((prev: string[]) => 
      prev.includes(time) 
        ? prev.filter((t: string) => t !== time)
        : [...prev, time].sort()
    );
  };

  // ìŠ¤ì¼€ì¤„ ì €ì¥ (ë°±ì—”ë“œ + í‘¸ì‹œ ì•Œë¦¼)
  const handleSaveSchedule = async (): Promise<void> => {
    if (selectedTimes.length === 0) {
      Alert.alert('ì•Œë¦¼', 'ìµœì†Œ í•˜ë‚˜ì˜ ì‹œê°„ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
      return;
    }

    // ë¨¼ì € ì•Œë¦¼ ê¶Œí•œ í™•ì¸
    const hasPermission = await requestNotificationPermissions();
    if (!hasPermission) {
      Alert.alert(
        'ê¶Œí•œ í•„ìš”',
        'ì•Œë¦¼ ê¶Œí•œì´ ì—†ìœ¼ë©´ í‘¸ì‹œ ì•Œë¦¼ì„ ë°›ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\nìŠ¤ì¼€ì¤„ì€ ì €ì¥ë˜ì§€ë§Œ ì•± ë‚´ì—ì„œë§Œ ì•Œë¦¼ì´ ì‘ë™í•©ë‹ˆë‹¤.',
        [
          { text: 'ì·¨ì†Œ', style: 'cancel' },
          { text: 'ê·¸ë˜ë„ ì €ì¥', onPress: () => saveScheduleWithoutNotification() }
        ]
      );
      return;
    }

    setIsLoading(true);
    try {
      console.log('â° ìŠ¤ì¼€ì¤„ ì„¤ì • ìš”ì²­:', selectedTimes);
      
      // 1. ë°±ì—”ë“œì— ìŠ¤ì¼€ì¤„ ì €ì¥
      const response = await fetch(`${apiBaseUrl}/api/v1/schedule/set`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          user_id_str: userId,
          call_times: selectedTimes
        })
      });

      const result = await response.json();

      if (response.ok) {
        console.log('âœ… ë°±ì—”ë“œ ìŠ¤ì¼€ì¤„ ì„¤ì • ì„±ê³µ:', result);
        setSchedules(result.schedules);
        setSelectedTimes([]);
        
        // ë¡œì»¬ ì €ì¥
        await AsyncStorage.setItem('userSchedules', JSON.stringify(result.schedules));
        
        // 2. í‘¸ì‹œ ì•Œë¦¼ ìŠ¤ì¼€ì¤„ ì„¤ì •
        try {
          NotificationManager.scheduleConversationAlarm(selectedTimes);
          console.log('âœ… í‘¸ì‹œ ì•Œë¦¼ ì„¤ì • ì™„ë£Œ');
          
          Alert.alert(
            'ì„¤ì • ì™„ë£Œ! ğŸ‰',
            `ì •ì‹œ ëŒ€í™” ì•Œë¦¼ì´ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.\nì„¤ì •ëœ ì‹œê°„: ${selectedTimes.map(formatTime).join(', ')}\n\nğŸ“± ì•±ì´ êº¼ì ¸ìˆì–´ë„ ì•Œë¦¼ì´ ìš¸ë¦½ë‹ˆë‹¤!\nğŸ”” ì „í™”ë²¨ ê°™ì€ í° ì†Œë¦¬ì™€ ì§„ë™`,
            [{ text: 'í™•ì¸' }]
          );
        } catch (notificationError) {
          console.error('âŒ í‘¸ì‹œ ì•Œë¦¼ ì„¤ì • ì‹¤íŒ¨:', notificationError);
          Alert.alert('ì•Œë¦¼ ì„¤ì • ì‹¤íŒ¨', 'í‘¸ì‹œ ì•Œë¦¼ ì„¤ì •ì— ì‹¤íŒ¨í–ˆì§€ë§Œ ìŠ¤ì¼€ì¤„ì€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
        }
        
      } else {
        console.error('âŒ ë°±ì—”ë“œ ìŠ¤ì¼€ì¤„ ì„¤ì • ì‹¤íŒ¨:', result);
        Alert.alert('ì˜¤ë¥˜', result.detail || 'ìŠ¤ì¼€ì¤„ ì„¤ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
      }
    } catch (error) {
      console.error('âŒ ìŠ¤ì¼€ì¤„ ì„¤ì • ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜:', error);
      Alert.alert('ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜', 'ìŠ¤ì¼€ì¤„ì„ ì„¤ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    } finally {
      setIsLoading(false);
    }
  };

  // ê¶Œí•œ ì—†ì´ ìŠ¤ì¼€ì¤„ë§Œ ì €ì¥
  const saveScheduleWithoutNotification = async (): Promise<void> => {
    setIsLoading(true);
    try {
      const response = await fetch(`${apiBaseUrl}/api/v1/schedule/set`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          user_id_str: userId,
          call_times: selectedTimes
        })
      });

      const result = await response.json();

      if (response.ok) {
        setSchedules(result.schedules);
        setSelectedTimes([]);
        await AsyncStorage.setItem('userSchedules', JSON.stringify(result.schedules));
        
        Alert.alert(
          'ìŠ¤ì¼€ì¤„ ì €ì¥ë¨',
          'ë°±ì—”ë“œ ìŠ¤ì¼€ì¤„ì€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.\ní‘¸ì‹œ ì•Œë¦¼ì„ ë°›ìœ¼ë ¤ë©´ ì„¤ì •ì—ì„œ ì•Œë¦¼ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.',
          [{ text: 'í™•ì¸' }]
        );
      }
    } catch (error) {
      Alert.alert('ì˜¤ë¥˜', 'ìŠ¤ì¼€ì¤„ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    } finally {
      setIsLoading(false);
    }
  };

  // ìŠ¤ì¼€ì¤„ í† ê¸€
  const toggleSchedule = async (scheduleId: number, isEnabled: boolean): Promise<void> => {
    try {
      console.log('ğŸ”„ ìŠ¤ì¼€ì¤„ í† ê¸€:', scheduleId, isEnabled);
      
      const response = await fetch(`${apiBaseUrl}/api/v1/schedule/${scheduleId}/toggle`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ is_enabled: isEnabled })
      });

      const result = await response.json();

      if (response.ok) {
        console.log('âœ… ìŠ¤ì¼€ì¤„ í† ê¸€ ì„±ê³µ');
        // ë¡œì»¬ ìŠ¤ì¼€ì¤„ ìƒíƒœ ì—…ë°ì´íŠ¸
        const updatedSchedules = schedules.map((schedule: Schedule) => 
          schedule.id === scheduleId 
            ? { ...schedule, is_enabled: isEnabled }
            : schedule
        );
        setSchedules(updatedSchedules);
        await AsyncStorage.setItem('userSchedules', JSON.stringify(updatedSchedules));
        
        // í‘¸ì‹œ ì•Œë¦¼ë„ ì—…ë°ì´íŠ¸
        const activeTimes = updatedSchedules
          .filter(s => s.is_enabled)
          .map(s => s.call_time);
        NotificationManager.scheduleConversationAlarm(activeTimes);
        
      } else {
        console.error('âŒ ìŠ¤ì¼€ì¤„ í† ê¸€ ì‹¤íŒ¨:', result);
        Alert.alert('ì˜¤ë¥˜', result.detail || 'ìŠ¤ì¼€ì¤„ ë³€ê²½ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
      }
    } catch (error) {
      console.error('âŒ ìŠ¤ì¼€ì¤„ í† ê¸€ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜:', error);
      Alert.alert('ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜', 'ìŠ¤ì¼€ì¤„ì„ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }
  };

  // ëª¨ë“  ìŠ¤ì¼€ì¤„ ì œê±°
  const removeAllSchedules = async (): Promise<void> => {
    try {
      console.log('ğŸ—‘ï¸ ëª¨ë“  ìŠ¤ì¼€ì¤„ ì œê±°');
      
      const response = await fetch(`${apiBaseUrl}/api/v1/schedule/${userId}`, {
        method: 'DELETE'
      });

      const result = await response.json();

      if (response.ok) {
        console.log('âœ… ë°±ì—”ë“œ ìŠ¤ì¼€ì¤„ ì œê±° ì„±ê³µ');
        setSchedules([]);
        await AsyncStorage.removeItem('userSchedules');
        
        // í‘¸ì‹œ ì•Œë¦¼ë„ ëª¨ë‘ ì·¨ì†Œ
        NotificationManager.cancelAllNotifications();
        console.log('âœ… í‘¸ì‹œ ì•Œë¦¼ë„ ëª¨ë‘ ì·¨ì†Œë¨');
        
        Alert.alert('ì„±ê³µ', 'ëª¨ë“  ìŠ¤ì¼€ì¤„ê³¼ ì•Œë¦¼ì´ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.');
      } else {
        console.error('âŒ ìŠ¤ì¼€ì¤„ ì œê±° ì‹¤íŒ¨:', result);
        Alert.alert('ì˜¤ë¥˜', result.detail || 'ìŠ¤ì¼€ì¤„ ì œê±°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
      }
    } catch (error) {
      console.error('âŒ ìŠ¤ì¼€ì¤„ ì œê±° ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜:', error);
      Alert.alert('ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜', 'ìŠ¤ì¼€ì¤„ì„ ì œê±°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }
  };

  const handleRemoveAllSchedules = (): void => {
    Alert.alert(
      'ìŠ¤ì¼€ì¤„ ì œê±°',
      'ëª¨ë“  ì •ì‹œ ëŒ€í™” ì‹œê°„ê³¼ ì•Œë¦¼ì„ ì œê±°í•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
      [
        { text: 'ì·¨ì†Œ', style: 'cancel' },
        {
          text: 'ì œê±°',
          style: 'destructive',
          onPress: removeAllSchedules
        }
      ]
    );
  };

  // ì‹œê°„ í˜•ì‹ ë³€í™˜ í•¨ìˆ˜
  const formatTime = (timeStr: string): string => {
    const [hours, minutes] = timeStr.split(':');
    const hour = parseInt(hours);
    const ampm = hour >= 12 ? 'ì˜¤í›„' : 'ì˜¤ì „';
    const displayHour = hour > 12 ? hour - 12 : hour === 0 ? 12 : hour;
    return `${ampm} ${displayHour}:${minutes}`;
  };

  // ì¦‰ì‹œ í…ŒìŠ¤íŠ¸ ì•Œë¦¼
  const handleImmediateTest = (): void => {
    Alert.alert(
      'ì¦‰ì‹œ í…ŒìŠ¤íŠ¸',
      '5ì´ˆ í›„ì— ì¦‰ì‹œ í…ŒìŠ¤íŠ¸ ì•Œë¦¼ì´ ìš¸ë¦½ë‹ˆë‹¤.',
      [
        { text: 'ì·¨ì†Œ', style: 'cancel' },
        {
          text: 'ì¦‰ì‹œ í…ŒìŠ¤íŠ¸',
          onPress: () => {
            NotificationManager.testImmediateNotification();
          }
        }
      ]
    );
  };

  // í…ŒìŠ¤íŠ¸ ì•Œë¦¼
  const handleTestNotification = (): void => {
    Alert.alert(
      'í…ŒìŠ¤íŠ¸ ì•Œë¦¼',
      '1ë¶„ í›„ì— í…ŒìŠ¤íŠ¸ ì•Œë¦¼ì´ ìš¸ë¦½ë‹ˆë‹¤.',
      [
        { text: 'ì·¨ì†Œ', style: 'cancel' },
        {
          text: 'í…ŒìŠ¤íŠ¸ ì‹œì‘',
          onPress: () => {
            NotificationManager.testNotification();
          }
        }
      ]
    );
  };

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Text style={styles.backButton}>â€¹ ë’¤ë¡œ</Text>
        </TouchableOpacity>
        <Text style={styles.headerTitle}>ì •ì‹œ ëŒ€í™” ì„¤ì •</Text>
        <View style={{ flexDirection: 'row' }}>
          <TouchableOpacity onPress={handleTestNotification}>
            <Text style={styles.testButton}>ğŸ§ª 1ë¶„</Text>
          </TouchableOpacity>
          <TouchableOpacity onPress={handleImmediateTest} style={{ marginLeft: 8 }}>
            <Text style={styles.testButton}>âš¡ ì¦‰ì‹œ</Text>
          </TouchableOpacity>
          <TouchableOpacity onPress={() => NotificationManager.testSimpleSchedule()} style={{ marginLeft: 8 }}>
            <Text style={styles.testButton}>â° 10ì´ˆ</Text>
          </TouchableOpacity>
        </View>
      </View>

      <ScrollView style={styles.content}>
        {/* í˜„ì¬ ì„¤ì •ëœ ìŠ¤ì¼€ì¤„ */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>í˜„ì¬ ì„¤ì •ëœ ì‹œê°„</Text>
          {schedules.length > 0 ? (
            schedules.map((schedule: Schedule) => (
              <View key={schedule.id} style={styles.scheduleItem}>
                <Text style={styles.scheduleTime}>
                  {formatTime(schedule.call_time)}
                </Text>
                <Switch
                  value={schedule.is_enabled}
                  onValueChange={(value: boolean) => toggleSchedule(schedule.id, value)}
                  trackColor={{ false: '#ccc', true: '#007AFF' }}
                />
              </View>
            ))
          ) : (
            <Text style={styles.noScheduleText}>ì„¤ì •ëœ ì‹œê°„ì´ ì—†ìŠµë‹ˆë‹¤.</Text>
          )}
          
          {schedules.length > 0 && (
            <TouchableOpacity 
              style={styles.removeAllButton}
              onPress={handleRemoveAllSchedules}
            >
              <Text style={styles.removeAllButtonText}>ëª¨ë“  ìŠ¤ì¼€ì¤„ ì œê±°</Text>
            </TouchableOpacity>
          )}
        </View>

        {/* ìƒˆ ì‹œê°„ ì¶”ê°€ */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>ìƒˆ ì‹œê°„ ì¶”ê°€</Text>
          <Text style={styles.sectionDescription}>
            ë§ë²—ê³¼ ëŒ€í™”í•  ì‹œê°„ì„ ì„ íƒí•˜ì„¸ìš”. (ë³µìˆ˜ ì„ íƒ ê°€ëŠ¥)
          </Text>
          
          <View style={styles.timeGrid}>
            {timeOptions.map((option: TimeOption) => (
              <TouchableOpacity
                key={option.time}
                style={[
                  styles.timeOption,
                  selectedTimes.includes(option.time) && styles.timeOptionSelected
                ]}
                onPress={() => toggleTimeSelection(option.time)}
              >
                <Text style={[
                  styles.timeOptionText,
                  selectedTimes.includes(option.time) && styles.timeOptionTextSelected
                ]}>
                  {option.label}
                </Text>
              </TouchableOpacity>
            ))}
          </View>

          {selectedTimes.length > 0 && (
            <View style={styles.selectedTimesContainer}>
              <Text style={styles.selectedTimesTitle}>ì„ íƒëœ ì‹œê°„:</Text>
              <Text style={styles.selectedTimesText}>
                {selectedTimes.map((time: string) => formatTime(time)).join(', ')}
              </Text>
            </View>
          )}

          <TouchableOpacity
            style={[
              styles.saveButton,
              (selectedTimes.length === 0 || isLoading) && styles.saveButtonDisabled
            ]}
            onPress={handleSaveSchedule}
            disabled={selectedTimes.length === 0 || isLoading}
          >
            <Text style={styles.saveButtonText}>
              {isLoading ? 'ì €ì¥ ì¤‘...' : 'ìŠ¤ì¼€ì¤„ ì €ì¥'}
            </Text>
          </TouchableOpacity>
        </View>

        {/* ì•ˆë‚´ ë©”ì‹œì§€ */}
        <View style={styles.infoSection}>
          <Text style={styles.infoTitle}>ğŸ”” ì•Œë¦¼ ê¸°ëŠ¥</Text>
          <Text style={styles.infoText}>
            â€¢ ì„¤ì •í•œ ì‹œê°„ì— **ì•±ì´ êº¼ì ¸ìˆì–´ë„** ì•Œë¦¼ì´ ìš¸ë¦½ë‹ˆë‹¤{'\n'}
            â€¢ ì „í™”ë²¨ì²˜ëŸ¼ **í° ì†Œë¦¬ì™€ ì§„ë™**ìœ¼ë¡œ ì•Œë¦¼{'\n'}
            â€¢ ì•Œë¦¼ì„ í„°ì¹˜í•˜ë©´ ë°”ë¡œ ëŒ€í™” ì‹œì‘ ê°€ëŠ¥{'\n'}
            â€¢ "10ë¶„ í›„ì—" ì—°ê¸° ê¸°ëŠ¥ ì œê³µ{'\n'}
            â€¢ ë¬´ìŒ ëª¨ë“œì—ì„œë„ ì•Œë¦¼ (ì¤‘ìš”ë„ ë†’ìŒ)
          </Text>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff'
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee'
  },
  backButton: {
    fontSize: 18,
    color: '#007AFF'
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: '600'
  },
  testButton: {
    fontSize: 14,
    color: '#FF9500'
  },
  content: {
    flex: 1,
    padding: 16
  },
  section: {
    marginBottom: 32
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 8,
    color: '#333'
  },
  sectionDescription: {
    fontSize: 14,
    color: '#666',
    marginBottom: 16
  },
  scheduleItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    backgroundColor: '#f8f9fa',
    borderRadius: 8,
    marginBottom: 8
  },
  scheduleTime: {
    fontSize: 16,
    fontWeight: '500'
  },
  noScheduleText: {
    fontSize: 16,
    color: '#999',
    textAlign: 'center',
    padding: 32
  },
  removeAllButton: {
    backgroundColor: '#FF3B30',
    padding: 12,
    borderRadius: 8,
    marginTop: 16
  },
  removeAllButtonText: {
    color: 'white',
    textAlign: 'center',
    fontWeight: '600'
  },
  timeGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between'
  },
  timeOption: {
    width: '48%',
    padding: 16,
    backgroundColor: '#f8f9fa',
    borderRadius: 8,
    marginBottom: 12,
    borderWidth: 2,
    borderColor: 'transparent'
  },
  timeOptionSelected: {
    backgroundColor: '#007AFF',
    borderColor: '#0056b3'
  },
  timeOptionText: {
    textAlign: 'center',
    fontSize: 14,
    fontWeight: '500',
    color: '#333'
  },
  timeOptionTextSelected: {
    color: 'white'
  },
  selectedTimesContainer: {
    backgroundColor: '#e3f2fd',
    padding: 16,
    borderRadius: 8,
    marginTop: 16
  },
  selectedTimesTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#1976d2',
    marginBottom: 4
  },
  selectedTimesText: {
    fontSize: 14,
    color: '#1976d2'
  },
  saveButton: {
    backgroundColor: '#007AFF',
    padding: 16,
    borderRadius: 8,
    marginTop: 24
  },
  saveButtonDisabled: {
    backgroundColor: '#ccc'
  },
  saveButtonText: {
    color: 'white',
    textAlign: 'center',
    fontSize: 16,
    fontWeight: '600'
  },
  infoSection: {
    backgroundColor: '#e8f5e8',
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#4caf50'
  },
  infoTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#2e7d32',
    marginBottom: 8
  },
  infoText: {
    fontSize: 14,
    color: '#2e7d32',
    lineHeight: 20
  }
});

export default SettingScreen;

-------------------------------------------------------------------------------

// @ts-nocheck
import PushNotification, { Importance } from 'react-native-push-notification';
import { PermissionsAndroid, Alert, Platform } from 'react-native';

interface NotificationUserInfo {
  action: string;
  scheduled_time?: string;
  user_id?: string;
}

// â—€ï¸ ìˆ˜ì •ë¨: ì±„ë„ IDë¥¼ 'v1'ë¡œ ë³€ê²½í•˜ì—¬ ì„¤ì •ì„ ê°•ì œë¡œ ìƒˆë¡œê³ ì¹¨í•©ë‹ˆë‹¤.
const NOTIFICATION_CHANNEL_ID = 'scheduled-call-high-v1';

class RealNotificationManager {
  private setScreenFunction: ((screen: string) => void) | null = null;

  constructor() {
    this.initializeNotifications();
  }

  // í™”ë©´ ì „í™˜ í•¨ìˆ˜ ì„¤ì •
  setScreen(setScreenFunc: (screen: string) => void): void {
    this.setScreenFunction = setScreenFunc;
    console.log('ğŸ¯ setCurrentScreen í•¨ìˆ˜ ì„¤ì •ë¨');
  }

  // ì•Œë¦¼ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
  private initializeNotifications(): void {
    PushNotification.configure({
      // ì•Œë¦¼ì„ ìˆ˜ì‹ í•˜ê±°ë‚˜ í„°ì¹˜í–ˆì„ ë•Œ í˜¸ì¶œë¨
      onNotification: (notification: any) => {
        console.log('ğŸ“± í‘¸ì‹œ ì•Œë¦¼ ìˆ˜ì‹ :', JSON.stringify(notification, null, 2));

        // ì‚¬ìš©ìê°€ ì•Œë¦¼ì„ 'í„°ì¹˜'í–ˆì„ ë•Œë§Œ ì•„ë˜ ë¡œì§ì„ ì‹¤í–‰
        if (!notification.userInteraction) {
          console.log('â„¹ï¸ ì•Œë¦¼ì´ ìš¸ë ¸ì§€ë§Œ ì‚¬ìš©ìê°€ í„°ì¹˜í•˜ì§€ ì•ŠìŒ. (ì•± í¬ê·¸ë¼ìš´ë“œ ìƒíƒœ)');
          return;
        }

        console.log('âœ… ì‚¬ìš©ìê°€ ì•Œë¦¼ì„ í„°ì¹˜í–ˆìŠµë‹ˆë‹¤.');
        
        const notificationData = notification.data || notification.userInfo || {};
        const action = notificationData.action;

        // ì •ì‹œ ëŒ€í™” ì•Œë¦¼ ë˜ëŠ” ìŠ¤ëˆ„ì¦ˆëœ ì•Œë¦¼ì„ í„°ì¹˜í•œ ê²½ìš°
        if (action === 'scheduled_call') {
          console.log('ğŸ“ ì •ì‹œ ëŒ€í™” ì•Œë¦¼ í„°ì¹˜ - ë‹¤ì´ì–¼ë¡œê·¸ í‘œì‹œ ë¡œì§ ì‹¤í–‰');
          setTimeout(() => {
            this.showCallDialog(notificationData.scheduled_time);
          }, 500);
        }
      },

      onAction: (notification: any) => {
        console.log('ğŸš€ onAction ì½œë°± ì‹¤í–‰ë¨ (í˜„ì¬ ì‚¬ìš©ë˜ì§€ ì•Šì•„ì•¼ í•¨):', notification.action);
        if (notification.action === 'ì§€ê¸ˆëŒ€í™”' || notification.action === 'ëŒ€í™”í•˜ê¸°') {
            this.navigateToSpeakScreen();
        } else if (notification.action === '10ë¶„í›„' || notification.action === 'ë‹¤ì‹œì—°ê¸°') {
            this.snoozeAlarm(10);
        }
      },

      onRegister: (token: any) => {
        console.log('ğŸ“± í‘¸ì‹œ í† í°:', token);
      },

      permissions: { alert: true, badge: true, sound: true },
      popInitialNotification: true,
      requestPermissions: Platform.OS === 'ios',
    });

    this.createNotificationChannel();
  }

  // ì•Œë¦¼ ì±„ë„ ìƒì„± (Android)
  private createNotificationChannel(): void {
    PushNotification.createChannel(
      {
        channelId: NOTIFICATION_CHANNEL_ID, // â—€ï¸ ìˆ˜ì •ë¨: ìƒˆë¡œìš´ ì±„ë„ ID ì‚¬ìš©
        channelName: 'ì •ì‹œ ëŒ€í™” ì•Œë¦¼ v1', // ì±„ë„ ì´ë¦„ë„ ë³€ê²½í•˜ì—¬ êµ¬ë³„ ìš©ì´
        channelDescription: 'ì„¤ì •í•œ ì‹œê°„ì— ìš¸ë¦¬ëŠ” ëŒ€í™” ì•Œë¦¼',
        playSound: true,
        soundName: 'default', // ê¸°ë³¸ ì•Œë¦¼ ì†Œë¦¬ ì‚¬ìš©
        importance: Importance.HIGH,
        vibrate: true,
      },
      (created: boolean) => {
        console.log(`âœ… ì•Œë¦¼ ì±„ë„ [${NOTIFICATION_CHANNEL_ID}] ìƒì„± ì‹œë„... ìƒì„± ì—¬ë¶€: ${created}`);
        if (created) {
          console.log('â„¹ï¸ ìƒˆë¡œìš´ ì•Œë¦¼ ì±„ë„ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ì œ ì†Œë¦¬ê°€ ì •ìƒì ìœ¼ë¡œ ì¬ìƒë˜ì–´ì•¼ í•©ë‹ˆë‹¤.');
        } else {
          console.log('â„¹ï¸ ê¸°ì¡´ ì•Œë¦¼ ì±„ë„ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ì†Œë¦¬ ë¬¸ì œê°€ ê³„ì†ë˜ë©´ ì•±ì„ ì‚­ì œ í›„ ì¬ì„¤ì¹˜í•´ì£¼ì„¸ìš”.');
        }
      }
    );
  }

  // ê¶Œí•œ ìš”ì²­
  async requestPermissions(): Promise<boolean> {
    try {
      if (Platform.OS === 'android') {
        const granted = await PermissionsAndroid.request(
          PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS,
          {
            title: 'ğŸ”” ì•Œë¦¼ ê¶Œí•œ í•„ìš”',
            message: 'ì •ì‹œ ëŒ€í™” ì•Œë¦¼ì„ ë°›ê¸° ìœ„í•´ ì•Œë¦¼ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.\n\nì•±ì´ êº¼ì ¸ìˆì–´ë„ ì•Œë¦¼ì´ ìš¸ë¦½ë‹ˆë‹¤!',
            buttonPositive: 'í—ˆìš©',
            buttonNegative: 'ê±°ë¶€',
          }
        );
        return granted === PermissionsAndroid.RESULTS.GRANTED;
      }
      return true;
    } catch (err) {
      console.warn('ê¶Œí•œ ìš”ì²­ ì˜¤ë¥˜:', err);
      return false;
    }
  }

  // ì •ì‹œ ëŒ€í™” ìŠ¤ì¼€ì¤„ ì„¤ì •
  scheduleConversationAlarm(times: string[]): void {
    console.log('ğŸš€ scheduleConversationAlarm í˜¸ì¶œë¨:', times);
    PushNotification.cancelAllLocalNotifications();
    console.log('âœ… ê¸°ì¡´ ì•Œë¦¼ ëª¨ë‘ ì·¨ì†Œë¨');

    times.forEach((time: string, index: number) => {
      const [hours, minutes] = time.split(':').map(Number);
      const scheduledDate = this.getNextScheduledTime(hours, minutes);

      PushNotification.localNotificationSchedule({
        id: 1000 + index,
        channelId: NOTIFICATION_CHANNEL_ID, // â—€ï¸ ìˆ˜ì •ë¨: ìƒˆë¡œìš´ ì±„ë„ ID ì‚¬ìš©
        title: 'ğŸ“ ì •ì‹œ ëŒ€í™” ì‹œê°„ì´ì—ìš”!',
        message: 'ë§ë²—ê³¼ ëŒ€í™”ë¥¼ ì‹œì‘í•˜ì‹œê² ì–´ìš”? í„°ì¹˜í•´ì„œ ì•±ì„ ì—´ì–´ë³´ì„¸ìš”.',
        date: scheduledDate,
        repeatType: 'day',
        playSound: true,
        soundName: 'default',
        vibrate: true,
        vibration: 2000,
        importance: 'high',
        priority: 'high',
        allowWhileIdle: true,
        fullScreenIntent: true, // â—€ï¸ ì¶”ê°€ë¨: ì „í™” ìˆ˜ì‹  í™”ë©´ì²˜ëŸ¼ ì•Œë¦¼ì„ ë„ì›ë‹ˆë‹¤.
        userInfo: {
          action: 'scheduled_call',
          scheduled_time: time,
          user_id: 'user_1752303760586_8wi64r'
        } as NotificationUserInfo,
      });

      console.log(`âœ… ${time} í‘¸ì‹œ ì•Œë¦¼ ì„¤ì • ì™„ë£Œ (ID: ${1000 + index})`);
    });
  }

  private getNextScheduledTime(hours: number, minutes: number): Date {
    const now = new Date();
    const scheduledTime = new Date();
    scheduledTime.setHours(hours, minutes, 0, 0);
    if (scheduledTime <= now) {
      scheduledTime.setDate(scheduledTime.getDate() + 1);
    }
    return scheduledTime;
  }

  // ëŒ€í™” ë‹¤ì´ì–¼ë¡œê·¸ í‘œì‹œ
  private showCallDialog(scheduledTime?: string): void {
    Alert.alert(
      'ğŸ“ ì •ì‹œ ëŒ€í™” ì‹œê°„ì´ì—ìš”!',
      scheduledTime ? `${this.formatTime(scheduledTime)}ì— ì˜ˆì •ëœ ëŒ€í™” ì‹œê°„ì…ë‹ˆë‹¤.` : 'ì§€ê¸ˆ ëŒ€í™”ë¥¼ ì‹œì‘í•˜ì‹œê² ì–´ìš”?',
      [
        { text: 'ì§€ê¸ˆ ëŒ€í™”í•˜ê¸°', onPress: () => this.navigateToSpeakScreen() },
        { text: '10ë¶„ í›„ì—', onPress: () => this.snoozeAlarm(10) },
        { text: 'ê±´ë„ˆë›°ê¸°', style: 'cancel' }
      ]
    );
  }

  // ë§í•˜ê¸° í™”ë©´ìœ¼ë¡œ ì´ë™
  private navigateToSpeakScreen(): void {
    console.log('ğŸ¯ navigateToSpeakScreen í˜¸ì¶œë¨!');
    if (this.setScreenFunction) {
      console.log('âœ… ë§í•˜ê¸° í™”ë©´ìœ¼ë¡œ ì´ë™ ì‹¤í–‰');
      this.setScreenFunction('Speak');
    } else {
      console.error('âš ï¸ setCurrentScreen í•¨ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ');
      Alert.alert('ì˜¤ë¥˜', 'í™”ë©´ì„ ì´ë™í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì•±ì„ ë‹¤ì‹œ ì‹œì‘í•´ì£¼ì„¸ìš”.');
    }
  }

  // ìŠ¤ëˆ„ì¦ˆ (10ë¶„ í›„ ë‹¤ì‹œ ì•Œë¦¼)
  private snoozeAlarm(minutes: number): void {
    const snoozeTime = new Date();
    snoozeTime.setMinutes(snoozeTime.getMinutes() + minutes);

    PushNotification.localNotificationSchedule({
      id: 3001, // ìŠ¤ëˆ„ì¦ˆ ì „ìš© ID
      channelId: NOTIFICATION_CHANNEL_ID, // â—€ï¸ ìˆ˜ì •ë¨: ìƒˆë¡œìš´ ì±„ë„ ID ì‚¬ìš©
      title: 'ğŸ”” ì—°ê¸°ëœ ëŒ€í™” ì‹œê°„',
      message: 'ì´ì œ ëŒ€í™”ë¥¼ ì‹œì‘í•´ë³¼ê¹Œìš”?',
      date: snoozeTime,
      playSound: true,
      soundName: 'default',
      vibrate: true,
      allowWhileIdle: true,
      fullScreenIntent: true, // â—€ï¸ ì¶”ê°€ë¨: ìŠ¤ëˆ„ì¦ˆ ì•Œë¦¼ë„ ì „ì²´ í™”ë©´ìœ¼ë¡œ
      userInfo: { action: 'scheduled_call' } as NotificationUserInfo, 
    });

    Alert.alert('ì•Œë¦¼ ì—°ê¸°', `${minutes}ë¶„ í›„ì— ë‹¤ì‹œ ì•Œë ¤ë“œë¦´ê²Œìš”`);
  }

  private formatTime(timeStr: string): string {
    const [hours, minutes] = timeStr.split(':');
    const hour = parseInt(hours);
    const ampm = hour >= 12 ? 'ì˜¤í›„' : 'ì˜¤ì „';
    const displayHour = hour % 12 || 12;
    return `${ampm} ${displayHour}:${minutes}`;
  }

  cancelAllNotifications(): void {
    PushNotification.cancelAllLocalNotifications();
    console.log('ëª¨ë“  í‘¸ì‹œ ì•Œë¦¼ ì·¨ì†Œë¨');
  }

  async checkPermissions(): Promise<boolean> {
    try {
      if (Platform.OS === 'android') {
        return await PermissionsAndroid.check(PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS);
      }
      return true;
    } catch (err) {
      console.warn('ê¶Œí•œ í™•ì¸ ì˜¤ë¥˜:', err);
      return false;
    }
  }
}

export default new RealNotificationManager();