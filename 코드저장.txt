from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from app.db import models
from app.db.database import engine
from app.api.v1.api import api_router

# 서버 시작 시 models.py에 정의된 모든 테이블을 DB에 생성합니다.
models.Base.metadata.create_all(bind=engine)

app = FastAPI(
    title="Tripot API",
    description="트라이팟 서비스의 통합 API 서버입니다.",
    version="1.0.0"
)

# 신뢰할 수 있는 출처 목록을 명확하게 정의하여 CORS 문제를 해결합니다.
origins = [
    # 실제 앱/웹 주소 (예시)
    # "http://tripot.com",
    # "https://tripot.com",

    # 로컬 개발 및 테스트를 위한 주소
    "http://localhost",
    "http://localhost:8080", # Nginx
    "http://localhost:8889", # Backend Direct
    "null", # 로컬 HTML 파일 테스트용
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# '/api/v1' 경로로 들어오는 모든 요청을 api_router에게 위임합니다.
app.include_router(api_router, prefix="/api/v1")

# 서버 상태 확인용 루트 경로
@app.get("/", tags=["Default"])
def read_root():
    return {"message": "Welcome to Tripot Integrated Backend!"}










    import openai
import asyncio
import json
import os
import base64
import tempfile

from app.core.config import settings
# 순환 참조(Circular Dependency)를 피하기 위해, 이 파일에서는 다른 서비스 파일을 직접 import하지 않습니다.

# OpenAI 클라이언트 초기화
client = openai.OpenAI(api_key=settings.OPENAI_API_KEY)

# --- 1. Core AI Utilities (기존과 유사) ---

async def get_embedding(text: str) -> list[float]:
    """텍스트를 받아 임베딩 벡터를 반환합니다."""
    response = await asyncio.to_thread(
        client.embeddings.create, input=text, model="text-embedding-3-small"
    )
    return response.data[0].embedding

async def get_transcript_from_audio(audio_file_path: str) -> str:
    """오디오 파일 경로를 받아 STT(Speech-to-Text) 결과를 반환합니다."""
    with open(audio_file_path, "rb") as audio_file:
        transcript_response = await asyncio.to_thread(
            client.audio.transcriptions.create, model="whisper-1", file=audio_file, language="ko"
        )
    return transcript_response.text

async def get_ai_chat_completion(prompt: str, model: str = "gpt-4o", max_tokens: int = 150, temperature: float = 0.7) -> str:
    """주어진 프롬프트에 대한 AI 챗봇의 응답을 반환합니다."""
    messages = [
        {"role": "system", "content": "당신은 주어진 규칙과 페르소나를 완벽하게 따르는 AI 어시스턴트입니다."},
        {"role": "user", "content": prompt}
    ]
    chat_response = await asyncio.to_thread(
        client.chat.completions.create,
        model=model,
        messages=messages,
        max_tokens=max_tokens,
        temperature=temperature
    )
    return chat_response.choices[0].message.content

# --- 2. Main Real-time Conversation Logic (핵심 로직 이동) ---

def _load_talk_prompt():
    """prompts/talk_prompt.json 파일을 안전하게 읽어오는 헬퍼 함수"""
    prompt_file_path = os.path.join(os.path.dirname(__file__), '..', '..', 'prompts', 'talk_prompt.json')
    try:
        with open(prompt_file_path, 'r', encoding='utf-8') as f:
            return json.load(f)['main_chat_prompt']
    except Exception as e:
        print(f"❌ talk_prompt.json 파일을 불러오는 데 실패했습니다: {e}")
        return None

PROMPTS_CONFIG = _load_talk_prompt()

async def process_user_audio(user_id: str, audio_base64: str):
    """
    사용자의 음성 데이터를 받아 처리하고, AI의 최종 응답을 생성하는 전체 과정을 담당합니다.
    (기존 main.py의 process_audio_and_get_response 로직을 이곳으로 이동)
    """
    # 순환 참조 방지를 위해 필요할 때만 vector_db_service를 가져옵니다.
    from . import vector_db

    audio_data = base64.b64decode(audio_base64)
    with tempfile.NamedTemporaryFile(delete=False, suffix=".wav") as temp_audio:
        temp_audio.write(audio_data)
        temp_audio_path = temp_audio.name
    
    try:
        user_message = await get_transcript_from_audio(temp_audio_path)
        if not user_message.strip() or "시청해주셔서 감사합니다" in user_message:
            return None, "음, 잘 알아듣지 못했어요. 혹시 다시 한번 말씀해주시겠어요?"
        
        relevant_memories = await vector_db.search_memories(user_id, user_message)
        
        if not PROMPTS_CONFIG:
            return user_message, "대화 프롬프트 설정 파일을 불러올 수 없어 기본 응답을 드립니다."

        system_message = "\n".join(PROMPTS_CONFIG['system_message_base'])
        examples_text = "\n\n".join([f"상황: {ex['situation']}\n사용자 입력: {ex['user_input']}\nAI 응답: {ex['ai_response']}" for ex in PROMPTS_CONFIG['examples']])
        
        final_prompt = f"""# 페르소나\n{system_message}\n# 핵심 대화 규칙\n{"\n".join(PROMPTS_CONFIG['core_conversation_rules'])}\n# 응답 가이드라인\n{"\n".join(PROMPTS_CONFIG['guidelines_and_reactions'])}\n# 절대 금지사항\n{"\n".join(PROMPTS_CONFIG['strict_prohibitions'])}\n# 성공적인 대화 예시\n{examples_text}\n---\n이제 실제 대화를 시작합니다.\n--- 과거 대화 핵심 기억 ---\n{relevant_memories if relevant_memories else "이전 대화 기록이 없습니다."}\n--------------------\n현재 사용자 메시지: "{user_message}"\nAI 답변:"""
        
        ai_response = await get_ai_chat_completion(final_prompt)
        
        return user_message, ai_response
    finally:
        os.unlink(temp_audio_path)

# --- 3. Report Generation Logic (for background scripts) ---

def _get_report_prompt():
    """prompts/report_prompt.json 파일을 읽어오는 헬퍼 함수"""
    prompt_file_path = os.path.join(os.path.dirname(__file__), '..', '..', 'prompts', 'report_prompt.json')
    try:
        with open(prompt_file_path, 'r', encoding='utf-8') as f:
            return json.load(f).get("report_analysis_prompt")
    except Exception as e:
        print(f"❌ report_prompt.json 파일을 불러오는 데 실패했습니다: {e}")
        return None

def generate_summary_report(conversation_text: str) -> dict | None:
    """대화 내용을 분석하여 JSON 형식의 리포트를 생성합니다 (동기 방식)."""
    
    report_prompt_template = _get_report_prompt()
    if not conversation_text or not report_prompt_template:
        return None

    persona = report_prompt_template.get('persona', '당신은 전문 대화 분석 AI입니다.')
    instructions = "\n".join(report_prompt_template.get('instructions', []))
    output_format_example = json.dumps(report_prompt_template.get('OUTPUT_FORMAT', {}), ensure_ascii=False, indent=2)

    system_prompt = f"{persona}\n\n### 지시사항\n{instructions}\n\n### 출력 형식\n모든 결과는 아래와 같은 JSON 형식으로만 출력해야 합니다. 추가 설명이나 인사말 등 JSON 외의 텍스트는 절대 포함하지 마세요.\n{output_format_example}"
    user_prompt = f"### 분석할 대화 전문\n---\n{conversation_text}\n---"

    try:
        completion = client.chat.completions.create(
            model="gpt-4o", 
            response_format={"type": "json_object"},
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ]
        )
        return json.loads(completion.choices[0].message.content)
    except Exception as e:
        print(f"AI 리포트 생성 중 오류 발생: {e}")
        return None



---------------------------------------------------------------------------------------

// @ts-nocheck
import PushNotification, { Importance } from 'react-native-push-notification';
import { PermissionsAndroid, Alert, Platform, AppState } from 'react-native';

interface NotificationUserInfo {
  action: string;
  scheduled_time?: string;
  user_id?: string;
}

class RealNotificationManager {
  private setScreenFunction: ((screen: string) => void) | null = null;

  constructor() {
    this.initializeNotifications();
  }

  // setCurrentScreen 함수 설정
  setScreen(setScreenFunc: (screen: string) => void): void {
    this.setScreenFunction = setScreenFunc;
    console.log('🎯 setCurrentScreen 함수 설정됨');
  }

  // 알림 시스템 초기화
  private initializeNotifications(): void {
    PushNotification.configure({
      // 알림 터치 시 실행 (앱이 꺼져있어도 실행됨!)
      onNotification: (notification: any) => {
        console.log('📱 푸시 알림 터치됨:', JSON.stringify(notification, null, 2));
        console.log('📱 액션:', notification.action);
        console.log('📱 사용자 정보:', notification.userInfo);
        console.log('📱 data:', notification.data);
        
        // 액션 버튼이 눌린 경우
        if (notification.action) {
          console.log('🔥 액션 버튼 클릭됨:', notification.action);
          if (notification.action === '지금대화') {
            console.log('🎯 지금 대화하기 - 말하기 화면으로 이동');
            this.navigateToSpeakScreen();
            return;
          } else if (notification.action === '10분후') {
            console.log('⏰ 10분 후 - 스누즈 알람 설정');
            this.snoozeAlarm(10);
            return;
          } else if (notification.action === '건너뛰기') {
            console.log('❌ 건너뛰기 - 아무것도 하지 않음');
            return;
          }
        }
        
        // 정시 대화 알림인 경우 (알림 자체를 터치한 경우)
        if (notification.data?.action === 'scheduled_call' || notification.userInfo?.action === 'scheduled_call') {
          console.log('📞 정시 대화 알림 터치 - 즉시 다이얼로그 표시');
          // 즉시 다이얼로그 표시 (딜레이 없이)
          this.showCallDialog(notification.data?.scheduled_time || notification.userInfo?.scheduled_time);
        }
        
        // 알림 처리 완료 표시 (중요!)
        if (notification.finish) {
          notification.finish(PushNotification.FetchResult.NoData);
        }
      },

      // 액션 버튼 처리
      onAction: (notification: any) => {
        console.log('🚀🚀🚀 onAction 콜백 실행됨!');
        console.log('📱 알림 액션 전체:', JSON.stringify(notification, null, 2));
        console.log('📱 액션:', notification.action);
        console.log('📱 사용자 정보:', notification.userInfo);
        
        // 알림으로도 알려주기
        Alert.alert('액션 버튼 클릭됨', `액션: ${notification.action}`);
        
        // 액션 버튼 처리 (띄어쓰기 없는 문자열)
        if (notification.action === '지금대화') {
          console.log('🎯 지금 대화하기 액션 실행');
          this.navigateToSpeakScreen();
        } else if (notification.action === '10분후') {
          console.log('⏰ 10분 후 액션 실행');
          this.snoozeAlarm(10);
        } else if (notification.action === '건너뛰기') {
          console.log('❌ 건너뛰기 액션 실행');
          // 아무것도 하지 않음
        } else if (notification.action === '대화하기') {
          console.log('🎯 대화하기 액션 실행 (스누즈에서)');
          this.navigateToSpeakScreen();
        } else if (notification.action === '다시연기') {
          console.log('⏰ 다시 연기 액션 실행');
          this.snoozeAlarm(10);
        } else {
          console.log('🤷 알 수 없는 액션:', notification.action);
        }
      },

      // 토큰 등록 (FCM용 - 나중에 사용)
      onRegister: (token: any) => {
        console.log('📱 푸시 토큰:', token);
      },

      // 권한
      permissions: {
        alert: true,
        badge: true,
        sound: true,
      },

      // 초기 알림 처리
      popInitialNotification: true,
      requestPermissions: Platform.OS === 'ios',
    });

    // 알림 채널 생성 (Android)
    this.createNotificationChannel();
  }

  // 알림 채널 생성
  private createNotificationChannel(): void {
    PushNotification.createChannel(
      {
        channelId: 'default-channel-id',
        channelName: '기본 알림',
        channelDescription: '앱의 기본 알림 채널',
        playSound: true,
        soundName: 'alarm.mp3', // 커스텀 알람 소리
        importance: Importance.HIGH,
        vibrate: true,
      },
      (created: boolean) => {
        console.log(`✅ 기본 알림 채널 생성: ${created}`);
        
        // 추가 채널도 생성
        PushNotification.createChannel(
          {
            channelId: 'scheduled-call-high',
            channelName: '정시 대화 알림',
            channelDescription: '설정한 시간에 울리는 대화 알림',
            playSound: true,
            soundName: 'alarm.mp3', // 커스텀 알람 소리
            importance: Importance.HIGH,
            vibrate: true,
          },
          (created2: boolean) => {
            console.log(`✅ 정시 대화 알림 채널 생성: ${created2}`);
          }
        );
      }
    );
  }

  // 권한 요청
  async requestPermissions(): Promise<boolean> {
    try {
      if (Platform.OS === 'android') {
        const granted = await PermissionsAndroid.request(
          PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS,
          {
            title: '🔔 알림 권한 필요',
            message: '정시 대화 알림을 받기 위해 알림 권한을 허용해주세요.\n\n앱이 꺼져있어도 알림이 울립니다!',
            buttonPositive: '허용',
            buttonNegative: '거부',
          }
        );
        return granted === PermissionsAndroid.RESULTS.GRANTED;
      }
      return true;
    } catch (err) {
      console.warn('권한 요청 오류:', err);
      return false;
    }
  }

  // 정시 대화 스케줄 설정 (진짜 푸시 알림)
  scheduleConversationAlarm(times: string[]): void {
    console.log('🚀 scheduleConversationAlarm 호출됨:', times);
    
    // 기존 예약된 알림 모두 취소
    PushNotification.cancelAllLocalNotifications();
    console.log('✅ 기존 알림 모두 취소됨');

    times.forEach((time: string, index: number) => {
      const [hours, minutes] = time.split(':').map(Number);
      const scheduledDate = this.getNextScheduledTime(hours, minutes);
      
      console.log(`⏰ 스케줄 ${index + 1}: ${time} → ${scheduledDate.toString()}`);

      // 진짜 푸시 알림 스케줄링 (앱이 꺼져있어도 작동!)
      PushNotification.localNotificationSchedule({
        id: 1000 + index, // 숫자 ID 사용
        channelId: 'scheduled-call-high',
        
        // 알림 내용
        title: '📞 정시 대화 시간이에요!',
        message: '말벗과 대화를 시작하시겠어요? 터치해서 앱을 열어보세요.',
        bigText: '설정하신 정시 대화 시간입니다. 지금 바로 대화를 시작하거나 10분 후로 연기할 수 있습니다.',
        
        // 시간 설정
        date: scheduledDate,
        repeatType: 'day',
        
        // 소리 및 진동 (강력하게!)
        playSound: true,
        soundName: 'alarm.mp3', // 커스텀 알람 소리
        vibrate: true,
        vibration: 2000,
        
        // 높은 우선순위
        importance: 'high',
        priority: 'high',
        
        // 잠금 화면에서도 표시
        visibility: 'public',
        
        // 앱 아이콘 뱃지
        number: 1,
        
        // 액션 버튼들 (띄어쓰기 없음)
        actions: ['지금대화', '10분후', '건너뛰기'],
        
        // 사용자 데이터
        userInfo: {
          action: 'scheduled_call',
          scheduled_time: time,
          user_id: 'user_1752303760586_8wi64r'
        } as NotificationUserInfo,

        // Android 전용 설정
        autoCancel: true,
        largeIcon: 'ic_launcher',
        smallIcon: 'ic_notification',
        color: '#007AFF',
        ongoing: false,
      });

      console.log(`✅ ${time} 진짜 푸시 알림 설정 완료 (ID: ${1000 + index})`);
    });
    
    console.log(`🎯 총 ${times.length}개 진짜 푸시 알림 설정 완료`);
  }

  // 다음 스케줄 시간 계산
  private getNextScheduledTime(hours: number, minutes: number): Date {
    const now = new Date();
    const scheduledTime = new Date();
    
    scheduledTime.setHours(hours, minutes, 0, 0);
    
    // 오늘 시간이 지났으면 내일로 설정
    if (scheduledTime <= now) {
      scheduledTime.setDate(scheduledTime.getDate() + 1);
    }
    
    return scheduledTime;
  }

  // 즉시 테스트 (진짜 푸시 알림)
  testImmediateNotification(): void {
    console.log('🚀 즉시 푸시 알림 테스트 시작');
    
    // 먼저 즉시 알림 시도
    PushNotification.localNotification({
      channelId: 'default-channel-id',
      title: '⚡ 즉시 테스트 알림',
      message: '즉시 알림이 표시되었습니다!',
      playSound: true,
      soundName: 'alarm.mp3', // 커스텀 알람 소리
      vibrate: true,
      vibration: 3000,
      importance: 'high',
      priority: 'high',
      userInfo: { action: 'immediate_test' } as NotificationUserInfo,
    });
    
    console.log('✅ 즉시 알림 설정 완료');
    
    // 5초 후에 다시 즉시 알림으로 테스트 (스케줄 대신)
    setTimeout(() => {
      console.log('🕐 5초 후 즉시 알림 실행');
      PushNotification.localNotification({
        channelId: 'default-channel-id',
        title: '⚡ 5초 후 즉시 알림',
        message: '이것도 즉시 알림입니다!',
        playSound: true,
        soundName: 'alarm.mp3', // 커스텀 알람 소리
        vibrate: true,
        vibration: 3000,
        importance: 'high',
        priority: 'high',
        userInfo: { action: 'delayed_immediate_test' } as NotificationUserInfo,
      });
    }, 5000);
    
    Alert.alert('즉시 + 5초 후 테스트', '즉시 알림이 나타났고, 5초 후에 또 다른 즉시 알림이 울립니다!');
  }

  // 1분 후 테스트 (setTimeout 사용)
  testNotification(): void {
    console.log('🧪 1분 후 푸시 알림 테스트 시작 (setTimeout 사용)');
    
    Alert.alert('1분 테스트 시작', '1분 후에 즉시 알림이 울립니다!\n(스케줄 대신 setTimeout 사용)');
    
    // setTimeout을 사용해서 1분 후에 즉시 알림
    setTimeout(() => {
      console.log('🕐 1분 후 즉시 알림 실행');
      PushNotification.localNotification({
        channelId: 'default-channel-id',
        title: '🧪 1분 후 테스트 성공!',
        message: 'setTimeout으로 1분 후 즉시 알림입니다!',
        playSound: true,
        soundName: 'alarm.mp3', // 커스텀 알람 소리
        vibrate: true,
        vibration: 2000,
        importance: 'high',
        priority: 'high',
        userInfo: { action: 'timeout_test' } as NotificationUserInfo,
      });
    }, 60000); // 60초 = 1분
    
    console.log('✅ 1분 후 setTimeout 알림 설정 완료');
  }

  // 간단한 스케줄 테스트 (10초 후)
  testSimpleSchedule(): void {
    console.log('⏰ 간단한 10초 스케줄 테스트');
    
    const testTime = new Date();
    testTime.setSeconds(testTime.getSeconds() + 10);
    
    console.log('예약 시간:', testTime.toString());
    
    PushNotification.localNotificationSchedule({
      id: 2001, // 숫자 ID
      title: '⏰ 10초 스케줄 테스트',
      message: '10초 후 스케줄 알림입니다!',
      date: testTime,
      playSound: true,
      soundName: 'alarm.mp3', // 커스텀 알람 소리
      vibrate: true,
      userInfo: { action: 'simple_schedule_test' } as NotificationUserInfo,
    });
    
    console.log('✅ 10초 스케줄 알림 설정 완료');
    Alert.alert('10초 스케줄 테스트', '10초 후에 스케줄 알림이 울립니다!');
  }

  // 푸시 알림 터치 시 처리
  private handleScheduledCallNotification(notification: any): void {
    console.log('📞 정시 대화 알림 처리:', notification);
    
    // 앱이 포그라운드에 있으면 즉시 다이얼로그
    if (AppState.currentState === 'active') {
      this.showCallDialog(notification.userInfo?.scheduled_time);
    } else {
      // 앱이 백그라운드/종료 상태면 앱을 열고 다이얼로그
      this.bringAppToForegroundAndShowDialog(notification.userInfo?.scheduled_time);
    }
  }

  // 대화 다이얼로그 표시
  private showCallDialog(scheduledTime?: string): void {
    Alert.alert(
      '📞 정시 대화 시간이에요!',
      scheduledTime ? `${this.formatTime(scheduledTime)}에 예정된 대화 시간입니다.` : '지금 대화를 시작하시겠어요?',
      [
        {
          text: '지금 대화하기',
          onPress: () => {
            console.log('정시 대화 - 말하기 화면으로 이동');
            this.navigateToSpeakScreen();
          }
        },
        {
          text: '10분 후에',
          onPress: () => this.snoozeAlarm(10)
        },
        {
          text: '건너뛰기',
          style: 'cancel'
        }
      ]
    );
  }

  // 앱을 포그라운드로 가져오고 다이얼로그 표시
  private bringAppToForegroundAndShowDialog(scheduledTime?: string): void {
    // 잠시 후 다이얼로그 표시 (앱이 완전히 로드될 시간 확보)
    setTimeout(() => {
      this.showCallDialog(scheduledTime);
    }, 1000);
  }

  // 말하기 화면으로 이동
  private navigateToSpeakScreen(): void {
    console.log('🎯🎯🎯 navigateToSpeakScreen 호출됨!');
    console.log('setScreenFunction 상태:', this.setScreenFunction);
    
    if (this.setScreenFunction) {
      console.log('✅ 말하기 화면으로 이동 실행');
      this.setScreenFunction('Speak');
      console.log('✅ setScreenFunction(Speak) 호출 완료');
      
      // 추가로 Alert도 표시해서 확실히 확인
      setTimeout(() => {
        Alert.alert('화면 이동', '말하기 화면으로 이동했습니다!');
      }, 500);
    } else {
      console.error('⚠️⚠️⚠️ setCurrentScreen 함수가 설정되지 않음');
      Alert.alert('오류', 'setCurrentScreen 함수가 설정되지 않았습니다.');
    }
  }

  // 스누즈 (10분 후 다시 알림)
  private snoozeAlarm(minutes: number): void {
    const snoozeTime = new Date();
    snoozeTime.setMinutes(snoozeTime.getMinutes() + minutes);

    PushNotification.localNotificationSchedule({
      id: 3001, // 숫자 ID
      channelId: 'scheduled-call-high',
      title: '🔔 연기된 대화 시간',
      message: '이제 대화를 시작해볼까요?',
      date: snoozeTime,
      playSound: true,
      soundName: 'alarm.mp3', // 커스텀 알람 소리
      vibrate: true,
      vibration: 2000,
      importance: 'high',
      priority: 'high',
      actions: ['대화하기', '다시연기'], // 띄어쓰기 없음
      userInfo: { action: 'snooze_call' } as NotificationUserInfo,
    });

    Alert.alert('알림 연기', `${minutes}분 후에 다시 알려드릴게요`);
  }

  // 시간 형식 변환
  private formatTime(timeStr: string): string {
    const [hours, minutes] = timeStr.split(':');
    const hour = parseInt(hours);
    const ampm = hour >= 12 ? '오후' : '오전';
    const displayHour = hour > 12 ? hour - 12 : hour === 0 ? 12 : hour;
    return `${ampm} ${displayHour}:${minutes}`;
  }

  // 모든 알림 취소
  cancelAllNotifications(): void {
    PushNotification.cancelAllLocalNotifications();
    console.log('모든 푸시 알림 취소됨');
  }

  // 권한 확인
  async checkPermissions(): Promise<boolean> {
    try {
      if (Platform.OS === 'android') {
        const result = await PermissionsAndroid.check(
          PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS
        );
        console.log('현재 권한 상태:', result);
        return result;
      }
      return true;
    } catch (err) {
      console.warn('권한 확인 오류:', err);
      return false;
    }
  }
}

export default new RealNotificationManager();

------------------------------------------------------------------------------------

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  SafeAreaView,
  Switch,
  Alert
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import NotificationManager from '../utils/RealNotificationManager';

interface Schedule {
  id: number;
  call_time: string;
  is_enabled: boolean;
  created_at: string;
}

interface TimeOption {
  time: string;
  label: string;
}

interface SettingScreenProps {
  navigation: { 
    goBack: () => void; 
  };
  userId: string;
  apiBaseUrl: string;
}

const SettingScreen: React.FC<SettingScreenProps> = ({ navigation, userId, apiBaseUrl }) => {
  const [schedules, setSchedules] = useState<Schedule[]>([]);
  const [selectedTimes, setSelectedTimes] = useState<string[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(false);

  // 다양한 시간 옵션들 (복수 선택 가능)
  const timeOptions: TimeOption[] = [
    { time: '07:00', label: '오전 7시 (아침 일찍)' },
    { time: '08:00', label: '오전 8시 (아침)' },
    { time: '09:00', label: '오전 9시' },
    { time: '10:00', label: '오전 10시' },
    { time: '11:00', label: '오전 11시' },
    { time: '12:00', label: '오후 12시 (점심)' },
    { time: '13:00', label: '오후 1시' },
    { time: '14:00', label: '오후 2시' },
    { time: '15:00', label: '오후 3시' },
    { time: '16:19', label: '오후 4시' },
    { time: '17:00', label: '오후 5시' },
    { time: '18:00', label: '오후 6시' },
    { time: '19:00', label: '오후 7시 (저녁)' },
    { time: '20:00', label: '오후 8시' },
    { time: '21:00', label: '오후 9시' },
  ];

  useEffect(() => {
    loadUserSchedules();
    // 알림 권한 요청
    requestNotificationPermissions();
  }, []);

  // 알림 권한 요청 및 확인
  const requestNotificationPermissions = async () => {
    try {
      // 먼저 현재 권한 상태 확인
      const hasPermission = await NotificationManager.checkPermissions();
      
      if (hasPermission) {
        console.log('✅ 알림 권한이 이미 허용됨');
        return true;
      }

      // 권한 요청
      const granted = await NotificationManager.requestPermissions();
      
      if (granted) {
        console.log('✅ 알림 권한 허용됨');
        Alert.alert(
          '권한 허용 완료',
          '이제 정시 대화 알림을 받을 수 있습니다!',
          [{ text: '확인' }]
        );
        return true;
      } else {
        console.log('❌ 알림 권한 거부됨');
        Alert.alert(
          '알림 권한 필요',
          '정시 대화 알림을 받으려면 설정에서 알림 권한을 허용해주세요.\n\n설정 > 앱 > 트리팟 > 알림',
          [
            { text: '나중에' },
            { 
              text: '설정으로 이동', 
              onPress: () => {
                // 설정 앱으로 이동하는 로직 추가 가능
                console.log('설정 앱으로 이동 필요');
              }
            }
          ]
        );
        return false;
      }
    } catch (error) {
      console.error('권한 요청 실패:', error);
      return false;
    }
  };

  // 사용자 스케줄 조회
  const loadUserSchedules = async (): Promise<void> => {
    try {
      console.log('📋 스케줄 조회 요청');
      
      const response = await fetch(`${apiBaseUrl}/api/v1/schedule/${userId}`);
      const result = await response.json();

      if (response.ok) {
        console.log('✅ 스케줄 조회 성공:', result);
        setSchedules(result.schedules);
        
        // 로컬 저장
        await AsyncStorage.setItem('userSchedules', JSON.stringify(result.schedules));
      } else {
        console.error('❌ 스케줄 조회 실패:', result);
      }
    } catch (error) {
      console.error('❌ 스케줄 조회 네트워크 오류:', error);
    }
  };

  // 시간 선택 토글 (복수 선택 가능)
  const toggleTimeSelection = (time: string): void => {
    setSelectedTimes((prev: string[]) => 
      prev.includes(time) 
        ? prev.filter((t: string) => t !== time)
        : [...prev, time].sort()
    );
  };

  // 스케줄 저장 (백엔드 + 푸시 알림)
  const handleSaveSchedule = async (): Promise<void> => {
    if (selectedTimes.length === 0) {
      Alert.alert('알림', '최소 하나의 시간을 선택해주세요.');
      return;
    }

    // 먼저 알림 권한 확인
    const hasPermission = await requestNotificationPermissions();
    if (!hasPermission) {
      Alert.alert(
        '권한 필요',
        '알림 권한이 없으면 푸시 알림을 받을 수 없습니다.\n스케줄은 저장되지만 앱 내에서만 알림이 작동합니다.',
        [
          { text: '취소', style: 'cancel' },
          { text: '그래도 저장', onPress: () => saveScheduleWithoutNotification() }
        ]
      );
      return;
    }

    setIsLoading(true);
    try {
      console.log('⏰ 스케줄 설정 요청:', selectedTimes);
      
      // 1. 백엔드에 스케줄 저장
      const response = await fetch(`${apiBaseUrl}/api/v1/schedule/set`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          user_id_str: userId,
          call_times: selectedTimes
        })
      });

      const result = await response.json();

      if (response.ok) {
        console.log('✅ 백엔드 스케줄 설정 성공:', result);
        setSchedules(result.schedules);
        setSelectedTimes([]);
        
        // 로컬 저장
        await AsyncStorage.setItem('userSchedules', JSON.stringify(result.schedules));
        
        // 2. 푸시 알림 스케줄 설정
        try {
          NotificationManager.scheduleConversationAlarm(selectedTimes);
          console.log('✅ 푸시 알림 설정 완료');
          
          Alert.alert(
            '설정 완료! 🎉',
            `정시 대화 알림이 설정되었습니다.\n설정된 시간: ${selectedTimes.map(formatTime).join(', ')}\n\n📱 앱이 꺼져있어도 알림이 울립니다!\n🔔 전화벨 같은 큰 소리와 진동`,
            [{ text: '확인' }]
          );
        } catch (notificationError) {
          console.error('❌ 푸시 알림 설정 실패:', notificationError);
          Alert.alert('알림 설정 실패', '푸시 알림 설정에 실패했지만 스케줄은 저장되었습니다.');
        }
        
      } else {
        console.error('❌ 백엔드 스케줄 설정 실패:', result);
        Alert.alert('오류', result.detail || '스케줄 설정에 실패했습니다.');
      }
    } catch (error) {
      console.error('❌ 스케줄 설정 네트워크 오류:', error);
      Alert.alert('네트워크 오류', '스케줄을 설정할 수 없습니다.');
    } finally {
      setIsLoading(false);
    }
  };

  // 권한 없이 스케줄만 저장
  const saveScheduleWithoutNotification = async (): Promise<void> => {
    setIsLoading(true);
    try {
      const response = await fetch(`${apiBaseUrl}/api/v1/schedule/set`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          user_id_str: userId,
          call_times: selectedTimes
        })
      });

      const result = await response.json();

      if (response.ok) {
        setSchedules(result.schedules);
        setSelectedTimes([]);
        await AsyncStorage.setItem('userSchedules', JSON.stringify(result.schedules));
        
        Alert.alert(
          '스케줄 저장됨',
          '백엔드 스케줄은 저장되었습니다.\n푸시 알림을 받으려면 설정에서 알림 권한을 허용해주세요.',
          [{ text: '확인' }]
        );
      }
    } catch (error) {
      Alert.alert('오류', '스케줄 저장에 실패했습니다.');
    } finally {
      setIsLoading(false);
    }
  };

  // 스케줄 토글
  const toggleSchedule = async (scheduleId: number, isEnabled: boolean): Promise<void> => {
    try {
      console.log('🔄 스케줄 토글:', scheduleId, isEnabled);
      
      const response = await fetch(`${apiBaseUrl}/api/v1/schedule/${scheduleId}/toggle`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ is_enabled: isEnabled })
      });

      const result = await response.json();

      if (response.ok) {
        console.log('✅ 스케줄 토글 성공');
        // 로컬 스케줄 상태 업데이트
        const updatedSchedules = schedules.map((schedule: Schedule) => 
          schedule.id === scheduleId 
            ? { ...schedule, is_enabled: isEnabled }
            : schedule
        );
        setSchedules(updatedSchedules);
        await AsyncStorage.setItem('userSchedules', JSON.stringify(updatedSchedules));
        
        // 푸시 알림도 업데이트
        const activeTimes = updatedSchedules
          .filter(s => s.is_enabled)
          .map(s => s.call_time);
        NotificationManager.scheduleConversationAlarm(activeTimes);
        
      } else {
        console.error('❌ 스케줄 토글 실패:', result);
        Alert.alert('오류', result.detail || '스케줄 변경에 실패했습니다.');
      }
    } catch (error) {
      console.error('❌ 스케줄 토글 네트워크 오류:', error);
      Alert.alert('네트워크 오류', '스케줄을 변경할 수 없습니다.');
    }
  };

  // 모든 스케줄 제거
  const removeAllSchedules = async (): Promise<void> => {
    try {
      console.log('🗑️ 모든 스케줄 제거');
      
      const response = await fetch(`${apiBaseUrl}/api/v1/schedule/${userId}`, {
        method: 'DELETE'
      });

      const result = await response.json();

      if (response.ok) {
        console.log('✅ 백엔드 스케줄 제거 성공');
        setSchedules([]);
        await AsyncStorage.removeItem('userSchedules');
        
        // 푸시 알림도 모두 취소
        NotificationManager.cancelAllNotifications();
        console.log('✅ 푸시 알림도 모두 취소됨');
        
        Alert.alert('성공', '모든 스케줄과 알림이 제거되었습니다.');
      } else {
        console.error('❌ 스케줄 제거 실패:', result);
        Alert.alert('오류', result.detail || '스케줄 제거에 실패했습니다.');
      }
    } catch (error) {
      console.error('❌ 스케줄 제거 네트워크 오류:', error);
      Alert.alert('네트워크 오류', '스케줄을 제거할 수 없습니다.');
    }
  };

  const handleRemoveAllSchedules = (): void => {
    Alert.alert(
      '스케줄 제거',
      '모든 정시 대화 시간과 알림을 제거하시겠습니까?',
      [
        { text: '취소', style: 'cancel' },
        {
          text: '제거',
          style: 'destructive',
          onPress: removeAllSchedules
        }
      ]
    );
  };

  // 시간 형식 변환 함수
  const formatTime = (timeStr: string): string => {
    const [hours, minutes] = timeStr.split(':');
    const hour = parseInt(hours);
    const ampm = hour >= 12 ? '오후' : '오전';
    const displayHour = hour > 12 ? hour - 12 : hour === 0 ? 12 : hour;
    return `${ampm} ${displayHour}:${minutes}`;
  };

  // 즉시 테스트 알림
  const handleImmediateTest = (): void => {
    Alert.alert(
      '즉시 테스트',
      '5초 후에 즉시 테스트 알림이 울립니다.',
      [
        { text: '취소', style: 'cancel' },
        {
          text: '즉시 테스트',
          onPress: () => {
            NotificationManager.testImmediateNotification();
          }
        }
      ]
    );
  };

  // 테스트 알림
  const handleTestNotification = (): void => {
    Alert.alert(
      '테스트 알림',
      '1분 후에 테스트 알림이 울립니다.',
      [
        { text: '취소', style: 'cancel' },
        {
          text: '테스트 시작',
          onPress: () => {
            NotificationManager.testNotification();
          }
        }
      ]
    );
  };

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Text style={styles.backButton}>‹ 뒤로</Text>
        </TouchableOpacity>
        <Text style={styles.headerTitle}>정시 대화 설정</Text>
        <View style={{ flexDirection: 'row' }}>
          <TouchableOpacity onPress={handleTestNotification}>
            <Text style={styles.testButton}>🧪 1분</Text>
          </TouchableOpacity>
          <TouchableOpacity onPress={handleImmediateTest} style={{ marginLeft: 8 }}>
            <Text style={styles.testButton}>⚡ 즉시</Text>
          </TouchableOpacity>
          <TouchableOpacity onPress={() => NotificationManager.testSimpleSchedule()} style={{ marginLeft: 8 }}>
            <Text style={styles.testButton}>⏰ 10초</Text>
          </TouchableOpacity>
        </View>
      </View>

      <ScrollView style={styles.content}>
        {/* 현재 설정된 스케줄 */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>현재 설정된 시간</Text>
          {schedules.length > 0 ? (
            schedules.map((schedule: Schedule) => (
              <View key={schedule.id} style={styles.scheduleItem}>
                <Text style={styles.scheduleTime}>
                  {formatTime(schedule.call_time)}
                </Text>
                <Switch
                  value={schedule.is_enabled}
                  onValueChange={(value: boolean) => toggleSchedule(schedule.id, value)}
                  trackColor={{ false: '#ccc', true: '#007AFF' }}
                />
              </View>
            ))
          ) : (
            <Text style={styles.noScheduleText}>설정된 시간이 없습니다.</Text>
          )}
          
          {schedules.length > 0 && (
            <TouchableOpacity 
              style={styles.removeAllButton}
              onPress={handleRemoveAllSchedules}
            >
              <Text style={styles.removeAllButtonText}>모든 스케줄 제거</Text>
            </TouchableOpacity>
          )}
        </View>

        {/* 새 시간 추가 */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>새 시간 추가</Text>
          <Text style={styles.sectionDescription}>
            말벗과 대화할 시간을 선택하세요. (복수 선택 가능)
          </Text>
          
          <View style={styles.timeGrid}>
            {timeOptions.map((option: TimeOption) => (
              <TouchableOpacity
                key={option.time}
                style={[
                  styles.timeOption,
                  selectedTimes.includes(option.time) && styles.timeOptionSelected
                ]}
                onPress={() => toggleTimeSelection(option.time)}
              >
                <Text style={[
                  styles.timeOptionText,
                  selectedTimes.includes(option.time) && styles.timeOptionTextSelected
                ]}>
                  {option.label}
                </Text>
              </TouchableOpacity>
            ))}
          </View>

          {selectedTimes.length > 0 && (
            <View style={styles.selectedTimesContainer}>
              <Text style={styles.selectedTimesTitle}>선택된 시간:</Text>
              <Text style={styles.selectedTimesText}>
                {selectedTimes.map((time: string) => formatTime(time)).join(', ')}
              </Text>
            </View>
          )}

          <TouchableOpacity
            style={[
              styles.saveButton,
              (selectedTimes.length === 0 || isLoading) && styles.saveButtonDisabled
            ]}
            onPress={handleSaveSchedule}
            disabled={selectedTimes.length === 0 || isLoading}
          >
            <Text style={styles.saveButtonText}>
              {isLoading ? '저장 중...' : '스케줄 저장'}
            </Text>
          </TouchableOpacity>
        </View>

        {/* 안내 메시지 */}
        <View style={styles.infoSection}>
          <Text style={styles.infoTitle}>🔔 알림 기능</Text>
          <Text style={styles.infoText}>
            • 설정한 시간에 **앱이 꺼져있어도** 알림이 울립니다{'\n'}
            • 전화벨처럼 **큰 소리와 진동**으로 알림{'\n'}
            • 알림을 터치하면 바로 대화 시작 가능{'\n'}
            • "10분 후에" 연기 기능 제공{'\n'}
            • 무음 모드에서도 알림 (중요도 높음)
          </Text>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff'
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee'
  },
  backButton: {
    fontSize: 18,
    color: '#007AFF'
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: '600'
  },
  testButton: {
    fontSize: 14,
    color: '#FF9500'
  },
  content: {
    flex: 1,
    padding: 16
  },
  section: {
    marginBottom: 32
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 8,
    color: '#333'
  },
  sectionDescription: {
    fontSize: 14,
    color: '#666',
    marginBottom: 16
  },
  scheduleItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    backgroundColor: '#f8f9fa',
    borderRadius: 8,
    marginBottom: 8
  },
  scheduleTime: {
    fontSize: 16,
    fontWeight: '500'
  },
  noScheduleText: {
    fontSize: 16,
    color: '#999',
    textAlign: 'center',
    padding: 32
  },
  removeAllButton: {
    backgroundColor: '#FF3B30',
    padding: 12,
    borderRadius: 8,
    marginTop: 16
  },
  removeAllButtonText: {
    color: 'white',
    textAlign: 'center',
    fontWeight: '600'
  },
  timeGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between'
  },
  timeOption: {
    width: '48%',
    padding: 16,
    backgroundColor: '#f8f9fa',
    borderRadius: 8,
    marginBottom: 12,
    borderWidth: 2,
    borderColor: 'transparent'
  },
  timeOptionSelected: {
    backgroundColor: '#007AFF',
    borderColor: '#0056b3'
  },
  timeOptionText: {
    textAlign: 'center',
    fontSize: 14,
    fontWeight: '500',
    color: '#333'
  },
  timeOptionTextSelected: {
    color: 'white'
  },
  selectedTimesContainer: {
    backgroundColor: '#e3f2fd',
    padding: 16,
    borderRadius: 8,
    marginTop: 16
  },
  selectedTimesTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#1976d2',
    marginBottom: 4
  },
  selectedTimesText: {
    fontSize: 14,
    color: '#1976d2'
  },
  saveButton: {
    backgroundColor: '#007AFF',
    padding: 16,
    borderRadius: 8,
    marginTop: 24
  },
  saveButtonDisabled: {
    backgroundColor: '#ccc'
  },
  saveButtonText: {
    color: 'white',
    textAlign: 'center',
    fontSize: 16,
    fontWeight: '600'
  },
  infoSection: {
    backgroundColor: '#e8f5e8',
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#4caf50'
  },
  infoTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#2e7d32',
    marginBottom: 8
  },
  infoText: {
    fontSize: 14,
    color: '#2e7d32',
    lineHeight: 20
  }
});

export default SettingScreen;

-------------------------------------------------------------------------------

// @ts-nocheck
import PushNotification, { Importance } from 'react-native-push-notification';
import { PermissionsAndroid, Alert, Platform } from 'react-native';

interface NotificationUserInfo {
  action: string;
  scheduled_time?: string;
  user_id?: string;
}

// ◀️ 수정됨: 채널 ID를 'v1'로 변경하여 설정을 강제로 새로고침합니다.
const NOTIFICATION_CHANNEL_ID = 'scheduled-call-high-v1';

class RealNotificationManager {
  private setScreenFunction: ((screen: string) => void) | null = null;

  constructor() {
    this.initializeNotifications();
  }

  // 화면 전환 함수 설정
  setScreen(setScreenFunc: (screen: string) => void): void {
    this.setScreenFunction = setScreenFunc;
    console.log('🎯 setCurrentScreen 함수 설정됨');
  }

  // 알림 시스템 초기화
  private initializeNotifications(): void {
    PushNotification.configure({
      // 알림을 수신하거나 터치했을 때 호출됨
      onNotification: (notification: any) => {
        console.log('📱 푸시 알림 수신:', JSON.stringify(notification, null, 2));

        // 사용자가 알림을 '터치'했을 때만 아래 로직을 실행
        if (!notification.userInteraction) {
          console.log('ℹ️ 알림이 울렸지만 사용자가 터치하지 않음. (앱 포그라운드 상태)');
          return;
        }

        console.log('✅ 사용자가 알림을 터치했습니다.');
        
        const notificationData = notification.data || notification.userInfo || {};
        const action = notificationData.action;

        // 정시 대화 알림 또는 스누즈된 알림을 터치한 경우
        if (action === 'scheduled_call') {
          console.log('📞 정시 대화 알림 터치 - 다이얼로그 표시 로직 실행');
          setTimeout(() => {
            this.showCallDialog(notificationData.scheduled_time);
          }, 500);
        }
      },

      onAction: (notification: any) => {
        console.log('🚀 onAction 콜백 실행됨 (현재 사용되지 않아야 함):', notification.action);
        if (notification.action === '지금대화' || notification.action === '대화하기') {
            this.navigateToSpeakScreen();
        } else if (notification.action === '10분후' || notification.action === '다시연기') {
            this.snoozeAlarm(10);
        }
      },

      onRegister: (token: any) => {
        console.log('📱 푸시 토큰:', token);
      },

      permissions: { alert: true, badge: true, sound: true },
      popInitialNotification: true,
      requestPermissions: Platform.OS === 'ios',
    });

    this.createNotificationChannel();
  }

  // 알림 채널 생성 (Android)
  private createNotificationChannel(): void {
    PushNotification.createChannel(
      {
        channelId: NOTIFICATION_CHANNEL_ID, // ◀️ 수정됨: 새로운 채널 ID 사용
        channelName: '정시 대화 알림 v1', // 채널 이름도 변경하여 구별 용이
        channelDescription: '설정한 시간에 울리는 대화 알림',
        playSound: true,
        soundName: 'default', // 기본 알림 소리 사용
        importance: Importance.HIGH,
        vibrate: true,
      },
      (created: boolean) => {
        console.log(`✅ 알림 채널 [${NOTIFICATION_CHANNEL_ID}] 생성 시도... 생성 여부: ${created}`);
        if (created) {
          console.log('ℹ️ 새로운 알림 채널이 생성되었습니다. 이제 소리가 정상적으로 재생되어야 합니다.');
        } else {
          console.log('ℹ️ 기존 알림 채널을 사용합니다. 소리 문제가 계속되면 앱을 삭제 후 재설치해주세요.');
        }
      }
    );
  }

  // 권한 요청
  async requestPermissions(): Promise<boolean> {
    try {
      if (Platform.OS === 'android') {
        const granted = await PermissionsAndroid.request(
          PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS,
          {
            title: '🔔 알림 권한 필요',
            message: '정시 대화 알림을 받기 위해 알림 권한을 허용해주세요.\n\n앱이 꺼져있어도 알림이 울립니다!',
            buttonPositive: '허용',
            buttonNegative: '거부',
          }
        );
        return granted === PermissionsAndroid.RESULTS.GRANTED;
      }
      return true;
    } catch (err) {
      console.warn('권한 요청 오류:', err);
      return false;
    }
  }

  // 정시 대화 스케줄 설정
  scheduleConversationAlarm(times: string[]): void {
    console.log('🚀 scheduleConversationAlarm 호출됨:', times);
    PushNotification.cancelAllLocalNotifications();
    console.log('✅ 기존 알림 모두 취소됨');

    times.forEach((time: string, index: number) => {
      const [hours, minutes] = time.split(':').map(Number);
      const scheduledDate = this.getNextScheduledTime(hours, minutes);

      PushNotification.localNotificationSchedule({
        id: 1000 + index,
        channelId: NOTIFICATION_CHANNEL_ID, // ◀️ 수정됨: 새로운 채널 ID 사용
        title: '📞 정시 대화 시간이에요!',
        message: '말벗과 대화를 시작하시겠어요? 터치해서 앱을 열어보세요.',
        date: scheduledDate,
        repeatType: 'day',
        playSound: true,
        soundName: 'default',
        vibrate: true,
        vibration: 2000,
        importance: 'high',
        priority: 'high',
        allowWhileIdle: true,
        fullScreenIntent: true, // ◀️ 추가됨: 전화 수신 화면처럼 알림을 띄웁니다.
        userInfo: {
          action: 'scheduled_call',
          scheduled_time: time,
          user_id: 'user_1752303760586_8wi64r'
        } as NotificationUserInfo,
      });

      console.log(`✅ ${time} 푸시 알림 설정 완료 (ID: ${1000 + index})`);
    });
  }

  private getNextScheduledTime(hours: number, minutes: number): Date {
    const now = new Date();
    const scheduledTime = new Date();
    scheduledTime.setHours(hours, minutes, 0, 0);
    if (scheduledTime <= now) {
      scheduledTime.setDate(scheduledTime.getDate() + 1);
    }
    return scheduledTime;
  }

  // 대화 다이얼로그 표시
  private showCallDialog(scheduledTime?: string): void {
    Alert.alert(
      '📞 정시 대화 시간이에요!',
      scheduledTime ? `${this.formatTime(scheduledTime)}에 예정된 대화 시간입니다.` : '지금 대화를 시작하시겠어요?',
      [
        { text: '지금 대화하기', onPress: () => this.navigateToSpeakScreen() },
        { text: '10분 후에', onPress: () => this.snoozeAlarm(10) },
        { text: '건너뛰기', style: 'cancel' }
      ]
    );
  }

  // 말하기 화면으로 이동
  private navigateToSpeakScreen(): void {
    console.log('🎯 navigateToSpeakScreen 호출됨!');
    if (this.setScreenFunction) {
      console.log('✅ 말하기 화면으로 이동 실행');
      this.setScreenFunction('Speak');
    } else {
      console.error('⚠️ setCurrentScreen 함수가 설정되지 않음');
      Alert.alert('오류', '화면을 이동할 수 없습니다. 앱을 다시 시작해주세요.');
    }
  }

  // 스누즈 (10분 후 다시 알림)
  private snoozeAlarm(minutes: number): void {
    const snoozeTime = new Date();
    snoozeTime.setMinutes(snoozeTime.getMinutes() + minutes);

    PushNotification.localNotificationSchedule({
      id: 3001, // 스누즈 전용 ID
      channelId: NOTIFICATION_CHANNEL_ID, // ◀️ 수정됨: 새로운 채널 ID 사용
      title: '🔔 연기된 대화 시간',
      message: '이제 대화를 시작해볼까요?',
      date: snoozeTime,
      playSound: true,
      soundName: 'default',
      vibrate: true,
      allowWhileIdle: true,
      fullScreenIntent: true, // ◀️ 추가됨: 스누즈 알림도 전체 화면으로
      userInfo: { action: 'scheduled_call' } as NotificationUserInfo, 
    });

    Alert.alert('알림 연기', `${minutes}분 후에 다시 알려드릴게요`);
  }

  private formatTime(timeStr: string): string {
    const [hours, minutes] = timeStr.split(':');
    const hour = parseInt(hours);
    const ampm = hour >= 12 ? '오후' : '오전';
    const displayHour = hour % 12 || 12;
    return `${ampm} ${displayHour}:${minutes}`;
  }

  cancelAllNotifications(): void {
    PushNotification.cancelAllLocalNotifications();
    console.log('모든 푸시 알림 취소됨');
  }

  async checkPermissions(): Promise<boolean> {
    try {
      if (Platform.OS === 'android') {
        return await PermissionsAndroid.check(PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS);
      }
      return true;
    } catch (err) {
      console.warn('권한 확인 오류:', err);
      return false;
    }
  }
}

export default new RealNotificationManager();